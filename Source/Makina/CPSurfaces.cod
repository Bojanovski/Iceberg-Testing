//
// FX Version: fx_5_0
//
// 2 local buffer(s)
//
cbuffer cbPerObject
{
    float4x4 gViewProj;                 // Offset:    0, size:   64
    float3  gEyePosW;                   // Offset:   64, size:   12
    float   gMaxTessDistance;           // Offset:   76, size:    4
    float   gMinTessDistance;           // Offset:   80, size:    4
    float   gMinTessFactor;             // Offset:   84, size:    4
    float   gMaxTessFactor;             // Offset:   88, size:    4
    int     gNU;                        // Offset:   92, size:    4
    int     gNV;                        // Offset:   96, size:    4
    float4  gCP[100];                   // Offset:  112, size: 1600
    float3  gCenter;                    // Offset: 1712, size:   12
}

cbuffer cbPerObjectAdditional
{
    DirectionalLight gDirLight;         // Offset:    0, size:   64
    Material gMaterial;                 // Offset:   64, size:   64
    float4x4 gShadowTransform;          // Offset:  128, size:   64
    float   gShadowMapSize;             // Offset:  192, size:    4
}

//
// 11 local object(s)
//
DepthStencilState DisableDepth
{
    DepthEnable = bool(FALSE /* 0 */);
    DepthWriteMask = uint(ZERO /* 0 */);
};
DepthStencilState NoDepthWrites
{
    DepthEnable = bool(TRUE /* 1 */);
    DepthWriteMask = uint(ZERO /* 0 */);
};
BlendState AdditiveBlending
{
    AlphaToCoverageEnable = bool(FALSE /* 0 */);
    BlendEnable[0] = bool(TRUE /* 1 */);
    SrcBlend[0] = uint(SRC_ALPHA /* 5 */);
    SrcBlend[1] = uint(SRC_ALPHA /* 5 */);
    SrcBlend[2] = uint(SRC_ALPHA /* 5 */);
    SrcBlend[3] = uint(SRC_ALPHA /* 5 */);
    SrcBlend[4] = uint(SRC_ALPHA /* 5 */);
    SrcBlend[5] = uint(SRC_ALPHA /* 5 */);
    SrcBlend[6] = uint(SRC_ALPHA /* 5 */);
    SrcBlend[7] = uint(SRC_ALPHA /* 5 */);
    DestBlend[0] = uint(ONE /* 2 */);
    DestBlend[1] = uint(ONE /* 2 */);
    DestBlend[2] = uint(ONE /* 2 */);
    DestBlend[3] = uint(ONE /* 2 */);
    DestBlend[4] = uint(ONE /* 2 */);
    DestBlend[5] = uint(ONE /* 2 */);
    DestBlend[6] = uint(ONE /* 2 */);
    DestBlend[7] = uint(ONE /* 2 */);
    BlendOp[0] = uint(ADD /* 1 */);
    BlendOp[1] = uint(ADD /* 1 */);
    BlendOp[2] = uint(ADD /* 1 */);
    BlendOp[3] = uint(ADD /* 1 */);
    BlendOp[4] = uint(ADD /* 1 */);
    BlendOp[5] = uint(ADD /* 1 */);
    BlendOp[6] = uint(ADD /* 1 */);
    BlendOp[7] = uint(ADD /* 1 */);
    SrcBlendAlpha[0] = uint(ZERO /* 1 */);
    SrcBlendAlpha[1] = uint(ZERO /* 1 */);
    SrcBlendAlpha[2] = uint(ZERO /* 1 */);
    SrcBlendAlpha[3] = uint(ZERO /* 1 */);
    SrcBlendAlpha[4] = uint(ZERO /* 1 */);
    SrcBlendAlpha[5] = uint(ZERO /* 1 */);
    SrcBlendAlpha[6] = uint(ZERO /* 1 */);
    SrcBlendAlpha[7] = uint(ZERO /* 1 */);
    DestBlendAlpha[0] = uint(ZERO /* 1 */);
    DestBlendAlpha[1] = uint(ZERO /* 1 */);
    DestBlendAlpha[2] = uint(ZERO /* 1 */);
    DestBlendAlpha[3] = uint(ZERO /* 1 */);
    DestBlendAlpha[4] = uint(ZERO /* 1 */);
    DestBlendAlpha[5] = uint(ZERO /* 1 */);
    DestBlendAlpha[6] = uint(ZERO /* 1 */);
    DestBlendAlpha[7] = uint(ZERO /* 1 */);
    BlendOpAlpha[0] = uint(ADD /* 1 */);
    BlendOpAlpha[1] = uint(ADD /* 1 */);
    BlendOpAlpha[2] = uint(ADD /* 1 */);
    BlendOpAlpha[3] = uint(ADD /* 1 */);
    BlendOpAlpha[4] = uint(ADD /* 1 */);
    BlendOpAlpha[5] = uint(ADD /* 1 */);
    BlendOpAlpha[6] = uint(ADD /* 1 */);
    BlendOpAlpha[7] = uint(ADD /* 1 */);
    RenderTargetWriteMask[0] = byte(0x0f);
};
RasterizerState Depth
{
    DepthBias = uint(0x00004e20);
    DepthBiasClamp = float(0);
    SlopeScaledDepthBias = float(1);
    CullMode = uint(NONE /* 1 */);
};
RasterizerState NoCulling
{
    CullMode = uint(NONE /* 1 */);
};
Texture2D gDiffuseMap;
Texture2D gShadowMap;
SamplerState fastSampler
{
    Filter   = uint(MIN_MAG_MIP_POINT /* 0 */);
    AddressU = uint(CLAMP /* 3 */);
    AddressV = uint(CLAMP /* 3 */);
};
SamplerState linearSampler
{
    Filter   = uint(MIN_MAG_MIP_LINEAR /* 21 */);
    AddressU = uint(CLAMP /* 3 */);
    AddressV = uint(CLAMP /* 3 */);
};
SamplerState samAnisotropic
{
    Filter   = uint(ANISOTROPIC /* 85 */);
    MaxAnisotropy = uint(4);
    AddressU = uint(CLAMP /* 3 */);
    AddressV = uint(CLAMP /* 3 */);
};
SamplerComparisonState samShadow
{
    Filter   = uint(COMPARISON_MIN_MAG_LINEAR_MIP_POINT /* 148 */);
    AddressU = uint(BORDER /* 4 */);
    AddressV = uint(BORDER /* 4 */);
    AddressW = uint(BORDER /* 4 */);
    BorderColor = float4(0, 0, 0, 0);
    ComparisonFunc = uint(LESS /* 2 */);
};

//
// 1 groups(s)
//
fxgroup
{
    //
    // 3 technique(s)
    //
    technique11 BSplineDraw_FinalComplete
    {
        pass P0
        {
            VertexShader = asm {
                //
                // Generated by Microsoft (R) HLSL Shader Compiler 9.29.952.3111
                //
                //
                //
                // Input signature:
                //
                // Name                 Index   Mask Register SysValue Format   Used
                // -------------------- ----- ------ -------- -------- ------ ------
                // TEXCOORD                 0   xy          0     NONE  float   xy  
                //
                //
                // Output signature:
                //
                // Name                 Index   Mask Register SysValue Format   Used
                // -------------------- ----- ------ -------- -------- ------ ------
                // TEXCOORD                 0   xy          0     NONE  float   xy  
                //
                vs_5_0
                dcl_globalFlags refactoringAllowed
                dcl_input v0.xy
                dcl_output o0.xy
                dcl_temps 1
                
                #line 11 "CPSurfaces-FinalComplete.fx"
                mov r0.xy, v0.xyxx  // vout<0,1>
                mov o0.xy, r0.xyxx  // VS<0,1>
                ret 
                // Approximately 3 instruction slots used
                            
            };
            HullShader = asm {
                //
                // Generated by Microsoft (R) HLSL Shader Compiler 9.29.952.3111
                //
                //
                // Buffer Definitions: 
                //
                // cbuffer cbPerObject
                // {
                //
                //   float4x4 gViewProj;                // Offset:    0 Size:    64 [unused]
                //   float3 gEyePosW;                   // Offset:   64 Size:    12
                //   float gMaxTessDistance;            // Offset:   76 Size:     4
                //   float gMinTessDistance;            // Offset:   80 Size:     4
                //   float gMinTessFactor;              // Offset:   84 Size:     4
                //   float gMaxTessFactor;              // Offset:   88 Size:     4
                //   int gNU;                           // Offset:   92 Size:     4 [unused]
                //   int gNV;                           // Offset:   96 Size:     4 [unused]
                //   float4 gCP[100];                   // Offset:  112 Size:  1600 [unused]
                //   float3 gCenter;                    // Offset: 1712 Size:    12
                //
                // }
                //
                //
                // Resource Bindings:
                //
                // Name                                 Type  Format         Dim Slot Elements
                // ------------------------------ ---------- ------- ----------- ---- --------
                // cbPerObject                       cbuffer      NA          NA    0        1
                //
                //
                //
                // Patch Constant signature:
                //
                // Name                 Index   Mask Register SysValue Format   Used
                // -------------------- ----- ------ -------- -------- ------ ------
                // SV_TessFactor            0   x           0  TRIEDGE  float   x   
                // SV_TessFactor            1   x           1  TRIEDGE  float   x   
                // SV_TessFactor            2   x           2  TRIEDGE  float   x   
                // SV_InsideTessFactor      0   x           3   TRIINT  float   x   
                //
                //
                // Input signature:
                //
                // Name                 Index   Mask Register SysValue Format   Used
                // -------------------- ----- ------ -------- -------- ------ ------
                // TEXCOORD                 0   xy          0     NONE  float   xy  
                //
                //
                // Output signature:
                //
                // Name                 Index   Mask Register SysValue Format   Used
                // -------------------- ----- ------ -------- -------- ------ ------
                // TEXCOORD                 0   xy          0     NONE  float   xy  
                //
                // Tessellation Domain   # of control points
                // -------------------- --------------------
                // Triangle                                3
                //
                // Tessellation Output Primitive  Partitioning Type 
                // ------------------------------ ------------------
                // Clockwise Triangles            Integer           
                //
                hs_5_0
                hs_decls 
                dcl_input_control_point_count 3
                dcl_output_control_point_count 3
                dcl_tessellator_domain domain_tri
                dcl_tessellator_partitioning partitioning_integer
                dcl_tessellator_output_primitive output_triangle_cw
                dcl_hs_max_tessfactor l(64.000000)
                dcl_globalFlags refactoringAllowed
                dcl_constantbuffer cb0[108], immediateIndexed
                
                #line 44 "CPSurfaces-FinalComplete.fx"
                hs_control_point_phase 
                dcl_input vOutputControlPointID
                dcl_input v[3][0].xy
                dcl_output o0.xy
                dcl_temps 1
                mov r0.x, vOutputControlPointID  // hout<0,1>
                mov r0.xy, v[r0.x + 0][0].xyxx  // HS<0,1>
                mov o0.xy, r0.xyxx
                
                #line 26
                ret 
                hs_join_phase   // p<0,1,2>
                dcl_output_siv o0.x, finalTriUeq0EdgeTessFactor
                dcl_output_siv o1.x, finalTriVeq0EdgeTessFactor
                dcl_output_siv o2.x, finalTriWeq0EdgeTessFactor
                dcl_output_siv o3.x, finalTriInsideTessFactor
                dcl_temps 2
                
                #line 85 "CPSurfaces-Utilities.fx"
                nop 
                mov r0.xyz, cb0[107].xyzx
                mov r1.xyz, -cb0[4].xyzx
                add r0.xyz, r0.xyzx, r1.xyzx  // d<0:NaN:Inf>
                dp3 r0.x, r0.xyzx, r0.xyzx
                sqrt r0.x, r0.x
                mov r0.y, -cb0[5].x
                add r0.x, r0.y, r0.x
                add r0.y, r0.y, cb0[4].w
                div r0.x, r0.x, r0.y  // s<0:[0f,1f]>
                max r0.x, r0.x, l(0.000000)
                min r0.x, r0.x, l(1.000000)
                log r0.x, r0.x
                mul r0.x, r0.x, l(1.500000)
                exp r0.x, r0.x
                mov r0.y, -cb0[5].y
                add r0.y, r0.y, cb0[5].z  // CalcTessFactor<0:NaN:Inf>
                
                #line 26 "CPSurfaces-FinalComplete.fx"
                mul r0.x, r0.y, r0.x  // tess<0:NaN:Inf>
                add r0.w, r0.x, cb0[5].y  // pt<0:NaN:Inf>
                
                #line 32
                mov r0.w, r0.w  // ConstantHS<0:NaN:Inf>
                mov r0.w, r0.w  // ConstantHS<1:NaN:Inf>
                mov r0.x, r0.w  // ConstantHS<2:NaN:Inf>
                mov r0.y, r0.w  // ConstantHS<3:NaN:Inf>
                mov r0.z, r0.w  // ConstantHS<0:Inf:[-1.#INFf,64f],1:Inf:[-1.#INFf,64f],2:Inf:[-1.#INFf,64f],3:Inf:[-1.#INFf,64f]>
                mov r0.w, r0.w  // ConstantHS<0:Inf:[-1.#INFf,64f]>
                min r0.xyzw, r0.xyzw, l(64.000000, 64.000000, 64.000000, 64.000000)  // ConstantHS<1:Inf:[-1.#INFf,64f]>
                mov o0.x, r0.x  // ConstantHS<2:Inf:[-1.#INFf,64f]>
                mov o1.x, r0.y  // ConstantHS<3:Inf:[-1.#INFf,64f]>
                mov o2.x, r0.z
                
                // incorrect instruction offset in debug info
                mov o3.x, r0.w
                // incorrect instruction offset in debug info
                
                
                // incorrect instruction offset in debug info
                ret 
                // incorrect instruction offset in debug info
                
                // Approximately 35 instruction slots used
                            
            };
            DomainShader = asm {
                //
                // Generated by Microsoft (R) HLSL Shader Compiler 9.29.952.3111
                //
                //
                // Buffer Definitions: 
                //
                // cbuffer cbPerObject
                // {
                //
                //   float4x4 gViewProj;                // Offset:    0 Size:    64 [unused]
                //   float3 gEyePosW;                   // Offset:   64 Size:    12 [unused]
                //   float gMaxTessDistance;            // Offset:   76 Size:     4 [unused]
                //   float gMinTessDistance;            // Offset:   80 Size:     4 [unused]
                //   float gMinTessFactor;              // Offset:   84 Size:     4 [unused]
                //   float gMaxTessFactor;              // Offset:   88 Size:     4 [unused]
                //   int gNU;                           // Offset:   92 Size:     4
                //   int gNV;                           // Offset:   96 Size:     4
                //   float4 gCP[100];                   // Offset:  112 Size:  1600
                //   float3 gCenter;                    // Offset: 1712 Size:    12
                //
                // }
                //
                //
                // Resource Bindings:
                //
                // Name                                 Type  Format         Dim Slot Elements
                // ------------------------------ ---------- ------- ----------- ---- --------
                // cbPerObject                       cbuffer      NA          NA    0        1
                //
                //
                //
                // Patch Constant signature:
                //
                // Name                 Index   Mask Register SysValue Format   Used
                // -------------------- ----- ------ -------- -------- ------ ------
                // SV_TessFactor            0   x           0  TRIEDGE  float       
                // SV_TessFactor            1   x           1  TRIEDGE  float       
                // SV_TessFactor            2   x           2  TRIEDGE  float       
                // SV_InsideTessFactor      0   x           3   TRIINT  float       
                //
                //
                // Input signature:
                //
                // Name                 Index   Mask Register SysValue Format   Used
                // -------------------- ----- ------ -------- -------- ------ ------
                // TEXCOORD                 0   xy          0     NONE  float   xy  
                //
                //
                // Output signature:
                //
                // Name                 Index   Mask Register SysValue Format   Used
                // -------------------- ----- ------ -------- -------- ------ ------
                // POSTION                  0   xyz         0     NONE  float   xyz 
                // NORMAL                   0   xyz         1     NONE  float   xyz 
                // TEXCOORD                 0   xy          2     NONE  float   xy  
                //
                // Tessellation Domain   # of control points
                // -------------------- --------------------
                // Triangle                                3
                //
                ds_5_0
                dcl_input_control_point_count 3
                dcl_tessellator_domain domain_tri
                dcl_globalFlags refactoringAllowed
                dcl_constantbuffer cb0[108], dynamicIndexed
                dcl_input vDomain.xyz
                dcl_input vicp[3][0].xy
                dcl_output o0.xyz
                dcl_output o1.xyz
                dcl_output o2.xy
                dcl_temps 10
                dcl_indexableTemp x0[36], 4
                dcl_indexableTemp x1[36], 4
                dcl_indexableTemp x2[36], 4
                dcl_indexableTemp x3[36], 4
                
                #line 52 "CPSurfaces-FinalComplete.fx"
                mul r0.xy, vDomain.xxxx, vicp[0][0].xyxx
                mul r0.zw, vDomain.yyyy, vicp[1][0].xxxy
                add r0.xy, r0.zwzz, r0.xyxx
                mul r0.zw, vDomain.zzzz, vicp[2][0].xxxy
                add r0.xy, r0.zwzz, r0.xyxx  // texCoord<0:NaN:Inf,1:NaN:Inf>
                
                #line 56
                nop 
                mov r0.xy, r0.xyxx  // texCoord<0:NaN:Inf,1:NaN:Inf>
                
                #line 148 "CPSurfaces-Utilities.fx"
                mov r0.z, r0.x  // u<0:NaN:Inf>
                mov r0.w, r0.y  // v<0:NaN:Inf>
                add r1.x, r0.z, l(0.000020)  // u_pdu<0:NaN:Inf>
                add r1.y, r0.y, l(0.000020)  // v_pdv<0:NaN:Inf>
                nop 
                mov r0.z, r0.z  // u<0:NaN:Inf>
                mov r1.z, cb0[5].w  // n<0>
                
                #line 143
                iadd r1.z, r1.z, l(-2)
                itof r1.z, r1.z
                mul r1.w, r0.z, r1.z
                mul r1.w, r1.w, l(0.999900)
                round_ni r1.w, r1.w
                ftoi r1.w, r1.w
                iadd r1.w, l(2), r1.w  // GetKey<0>
                
                #line 152
                mov r1.w, r1.w  // iU<0>
                nop 
                mov r0.w, r0.w  // u<0:NaN:Inf>
                mov r2.x, cb0[6].x  // n<0>
                
                #line 143
                iadd r2.x, r2.x, l(-2)
                itof r2.x, r2.x
                mul r2.y, r0.w, r2.x
                mul r2.y, r2.y, l(0.999900)
                round_ni r2.y, r2.y
                ftoi r2.y, r2.y
                iadd r2.y, l(2), r2.y  // GetKey<0>
                
                #line 153
                mov r2.y, r2.y  // iV<0>
                
                #line 163
                mov x3[r2.y + 0].x, l(1.000000)  // basisV_pdv[r2.y/3]<0:Inf>
                mov x2[r1.w + 0].x, l(1.000000)  // basisU_pdu[r1.w/3]<0:Inf>
                mov x1[r2.y + 0].x, l(1.000000)  // basisV[r2.y/3]<0:Inf>
                mov x0[r1.w + 0].x, l(1.000000)  // basisU[r1.w/3]<0:Inf>
                
                #line 175
                nop 
                
                #line 135
                iadd r2.z, r1.w, l(-2)
                itof r2.z, r2.z
                div r2.z, r2.z, r1.z
                max r2.z, r2.z, l(0.000000)
                min r2.z, r2.z, l(1.000000)  // GetKnot<0:[0f,1f]>
                
                #line 175
                mov r2.z, r2.z  // gKI<0:[0f,1f]>
                nop 
                iadd r2.w, r1.w, l(1)  // i<0>
                
                #line 135
                iadd r2.w, r2.w, l(-2)
                itof r2.w, r2.w
                div r2.w, r2.w, r1.z
                max r2.w, r2.w, l(0.000000)
                min r2.w, r2.w, l(1.000000)  // GetKnot<0:[0f,1f]>
                
                #line 176
                mov r2.w, r2.w  // gKI1<0:[0f,1f]>
                nop 
                nop 
                iadd r3.x, r1.w, l(-1)
                iadd r3.y, r3.x, l(1)  // i<0>
                
                #line 135
                iadd r3.y, r3.y, l(-2)
                itof r3.y, r3.y
                div r3.y, r3.y, r1.z
                max r3.y, r3.y, l(0.000000)
                min r3.y, r3.y, l(1.000000)  // GetKnot<0:[0f,1f]>
                
                #line 178
                mov r3.y, r3.y  // gKIJ1<0:[0f,1f]>
                mov r2.z, -r2.z
                add r3.z, r0.z, r2.z
                add r3.w, r2.z, r2.w
                div r4.x, r3.z, r3.w  // c0U<0:NaN:Inf>
                mov r4.y, -r0.z
                add r4.z, r2.w, r4.y
                mov r3.y, -r3.y
                add r3.y, r2.w, r3.y
                div r4.w, r4.z, r3.y  // c1U<0:NaN:Inf>
                mul r4.x, r4.x, l(1.000000)
                mov x0[r1.w + 12].x, r4.x  // basisU[r1.w/3]<12:Inf>
                mul r4.w, r4.w, l(1.000000)
                mov x0[r3.x + 12].x, r4.w  // basisU[r3.x/3]<12:Inf>
                add r5.x, r1.x, r2.z
                div r3.w, r5.x, r3.w  // c0U_pdu<0:NaN:Inf>
                mov r5.y, -r1.x
                add r5.z, r2.w, r5.y
                div r3.y, r5.z, r3.y  // c1U_pdu<0:NaN:Inf>
                mul r3.w, r3.w, l(1.000000)
                mov x2[r1.w + 12].x, r3.w  // basisU_pdu[r1.w/3]<12:Inf>
                mul r3.y, r3.y, l(1.000000)
                mov x2[r3.x + 12].x, r3.y  // basisU_pdu[r3.x/3]<12:Inf>
                
                #line 189
                nop 
                
                #line 135
                iadd r3.x, r2.y, l(-2)
                itof r3.x, r3.x
                div r3.x, r3.x, r2.x
                max r3.x, r3.x, l(0.000000)
                min r3.x, r3.x, l(1.000000)  // GetKnot<0:[0f,1f]>
                
                #line 189
                mov r3.x, r3.x  // gKI<0:[0f,1f]>
                nop 
                iadd r5.w, r2.y, l(1)  // i<0>
                
                #line 135
                iadd r5.w, r5.w, l(-2)
                itof r5.w, r5.w
                div r5.w, r5.w, r2.x
                max r5.w, r5.w, l(0.000000)
                min r5.w, r5.w, l(1.000000)  // GetKnot<0:[0f,1f]>
                
                #line 190
                mov r5.w, r5.w  // gKI1<0:[0f,1f]>
                nop 
                nop 
                iadd r6.x, r2.y, l(-1)
                iadd r6.y, r6.x, l(1)  // i<0>
                
                #line 135
                iadd r6.y, r6.y, l(-2)
                itof r6.y, r6.y
                div r6.y, r6.y, r2.x
                max r6.y, r6.y, l(0.000000)
                min r6.y, r6.y, l(1.000000)  // GetKnot<0:[0f,1f]>
                
                #line 192
                mov r6.y, r6.y  // gKIJ1<0:[0f,1f]>
                mov r3.x, -r3.x
                add r6.z, r0.w, r3.x
                add r6.w, r3.x, r5.w
                div r7.x, r6.z, r6.w  // c0V<0:NaN:Inf>
                mov r7.y, -r0.w
                add r7.z, r5.w, r7.y
                mov r6.y, -r6.y
                add r6.y, r5.w, r6.y
                div r7.w, r7.z, r6.y  // c1V<0:NaN:Inf>
                mul r7.x, r7.x, l(1.000000)
                mov x1[r2.y + 12].x, r7.x  // basisV[r2.y/3]<12:Inf>
                mul r7.w, r7.w, l(1.000000)
                mov x1[r6.x + 12].x, r7.w  // basisV[r6.x/3]<12:Inf>
                add r8.x, r1.y, r3.x
                div r6.w, r8.x, r6.w  // c0V_pdv<0:NaN:Inf>
                mov r8.y, -r1.y
                add r8.z, r5.w, r8.y
                div r6.y, r8.z, r6.y  // c1V_pdv<0:NaN:Inf>
                mul r6.w, r6.w, l(1.000000)
                mov x3[r2.y + 12].x, r6.w  // basisV_pdv[r2.y/3]<12:Inf>
                mul r6.y, r6.y, l(1.000000)
                mov x3[r6.x + 12].x, r6.y  // basisV_pdv[r6.x/3]<12:Inf>
                
                #line 175
                nop 
                nop 
                nop 
                iadd r6.x, r1.w, l(2)  // i<0>
                
                #line 135
                iadd r6.x, r6.x, l(-2)
                itof r6.x, r6.x
                div r6.x, r6.x, r1.z
                max r6.x, r6.x, l(0.000000)
                min r6.x, r6.x, l(1.000000)  // GetKnot<0:[0f,1f]>
                
                #line 177
                mov r6.x, r6.x  // gKIJ<0:[0f,1f]>
                nop 
                iadd r8.w, r1.w, l(-2)
                iadd r9.x, r8.w, l(1)  // i<0>
                
                #line 135
                iadd r9.y, r9.x, l(-2)
                itof r9.y, r9.y
                div r9.y, r9.y, r1.z
                max r9.y, r9.y, l(0.000000)
                min r9.y, r9.y, l(1.000000)  // GetKnot<0:[0f,1f]>
                
                #line 178
                mov r9.y, r9.y  // gKIJ1<0:[0f,1f]>
                add r2.z, r2.z, r6.x
                div r3.z, r3.z, r2.z  // c0U<0:NaN:Inf>
                mov r6.x, -r9.y
                add r2.w, r2.w, r6.x
                div r4.z, r4.z, r2.w  // c1U<0:NaN:Inf>
                mul r3.z, r4.x, r3.z
                mov x0[r1.w + 24].x, r3.z  // basisU[r1.w/3]<24:Inf>
                mul r3.z, r4.w, r4.z
                mov x0[r8.w + 24].x, r3.z  // basisU[r8.w/3]<24:Inf>
                div r2.z, r5.x, r2.z  // c0U_pdu<0:NaN:Inf>
                div r2.w, r5.z, r2.w  // c1U_pdu<0:NaN:Inf>
                mul r2.z, r3.w, r2.z
                mov x2[r1.w + 24].x, r2.z  // basisU_pdu[r1.w/3]<24:Inf>
                mul r2.z, r3.y, r2.w
                mov x2[r8.w + 24].x, r2.z  // basisU_pdu[r8.w/3]<24:Inf>
                
                #line 189
                nop 
                nop 
                nop 
                iadd r2.w, r2.y, l(2)  // i<0>
                
                #line 135
                iadd r2.w, r2.w, l(-2)
                itof r2.w, r2.w
                div r2.w, r2.w, r2.x
                max r2.w, r2.w, l(0.000000)
                min r2.w, r2.w, l(1.000000)  // GetKnot<0:[0f,1f]>
                
                #line 191
                mov r2.w, r2.w  // gKIJ<0:[0f,1f]>
                nop 
                iadd r4.z, r2.y, l(-2)
                iadd r5.x, r4.z, l(1)  // i<0>
                
                #line 135
                iadd r5.z, r5.x, l(-2)
                itof r5.z, r5.z
                div r5.z, r5.z, r2.x
                max r5.z, r5.z, l(0.000000)
                min r5.z, r5.z, l(1.000000)  // GetKnot<0:[0f,1f]>
                
                #line 192
                mov r5.z, r5.z  // gKIJ1<0:[0f,1f]>
                add r2.w, r3.x, r2.w
                div r3.x, r6.z, r2.w  // c0V<0:NaN:Inf>
                mov r5.z, -r5.z
                add r5.z, r5.z, r5.w
                div r5.w, r7.z, r5.z  // c1V<0:NaN:Inf>
                mul r3.x, r7.x, r3.x
                mov x1[r2.y + 24].x, r3.x  // basisV[r2.y/3]<24:Inf>
                mul r3.x, r7.w, r5.w
                mov x1[r4.z + 24].x, r3.x  // basisV[r4.z/3]<24:Inf>
                div r2.w, r8.x, r2.w  // c0V_pdv<0:NaN:Inf>
                div r5.z, r8.z, r5.z  // c1V_pdv<0:NaN:Inf>
                mul r2.w, r6.w, r2.w
                mov x3[r2.y + 24].x, r2.w  // basisV_pdv[r2.y/3]<24:Inf>
                mul r2.w, r6.y, r5.z
                mov x3[r4.z + 24].x, r2.w  // basisV_pdv[r4.z/3]<24:Inf>
                
                #line 209
                ilt r5.z, r9.x, r1.w
                if_nz r5.z
                  mov r5.z, r9.x  // k<0>
                  nop 
                  mov r5.z, r5.z  // i<0>
                
                #line 135
                  iadd r5.w, r5.z, l(-2)
                  itof r5.w, r5.w
                  div r5.w, r5.w, r1.z
                  max r5.w, r5.w, l(0.000000)
                  min r5.w, r5.w, l(1.000000)  // GetKnot<0:[0f,1f]>
                
                #line 211
                  mov r5.w, r5.w  // gKK<0:[0f,1f]>
                  nop 
                  iadd r6.x, r5.z, l(1)  // i<0>
                
                #line 135
                  iadd r6.x, r6.x, l(-2)
                  itof r6.x, r6.x
                  div r6.x, r6.x, r1.z
                  max r6.x, r6.x, l(0.000000)
                  min r6.x, r6.x, l(1.000000)  // GetKnot<0:[0f,1f]>
                
                #line 212
                  mov r6.x, r6.x  // gKK1<0:[0f,1f]>
                  nop 
                  iadd r6.z, r5.z, l(2)  // i<0>
                
                #line 135
                  iadd r7.z, r6.z, l(-2)
                  itof r7.z, r7.z
                  div r7.z, r7.z, r1.z
                  max r7.z, r7.z, l(0.000000)
                  min r7.z, r7.z, l(1.000000)  // GetKnot<0:[0f,1f]>
                
                #line 213
                  mov r7.z, r7.z  // gKKJ<0:[0f,1f]>
                  nop 
                  iadd r6.z, r6.z, l(1)  // i<0>
                
                #line 135
                  iadd r6.z, r6.z, l(-2)
                  itof r6.z, r6.z
                  div r1.z, r6.z, r1.z
                  max r1.z, r1.z, l(0.000000)
                  min r1.z, r1.z, l(1.000000)  // GetKnot<0:[0f,1f]>
                
                #line 214
                  mov r1.z, r1.z  // gKKJ1<0:[0f,1f]>
                  mov r5.w, -r5.w
                  add r0.z, r0.z, r5.w
                  add r6.z, r5.w, r7.z
                  div r0.z, r0.z, r6.z  // c0U<0:NaN:Inf>
                  add r4.y, r4.y, r1.z
                  mov r6.x, -r6.x
                  add r6.x, r1.z, r6.x
                  div r4.y, r4.y, r6.x  // c1U<0:NaN:Inf>
                  mul r0.z, r4.w, r0.z
                  mul r4.x, r4.x, r4.y
                  add r0.z, r0.z, r4.x
                  mov x0[r5.z + 24].x, r0.z  // basisU[r5.z/3]<24:Inf>
                  add r0.z, r1.x, r5.w
                  div r0.z, r0.z, r6.z  // c0U_pdu<0:NaN:Inf>
                  add r1.x, r5.y, r1.z
                  div r1.x, r1.x, r6.x  // c1U_pdu<0:NaN:Inf>
                  mul r0.z, r3.y, r0.z
                  mul r1.x, r3.w, r1.x
                  add r0.z, r0.z, r1.x
                  mov x2[r5.z + 24].x, r0.z  // basisU_pdu[r5.z/3]<24:Inf>
                
                #line 209
                endif 
                
                #line 225
                ilt r0.z, r5.x, r2.y
                if_nz r0.z
                  mov r0.z, r5.x  // k<0>
                  nop 
                  mov r0.z, r0.z  // i<0>
                
                #line 135
                  iadd r1.x, r0.z, l(-2)
                  itof r1.x, r1.x
                  div r1.x, r1.x, r2.x
                  max r1.x, r1.x, l(0.000000)
                  min r1.x, r1.x, l(1.000000)  // GetKnot<0:[0f,1f]>
                
                #line 227
                  mov r1.x, r1.x  // gKK<0:[0f,1f]>
                  nop 
                  iadd r1.z, r0.z, l(1)  // i<0>
                
                #line 135
                  iadd r1.z, r1.z, l(-2)
                  itof r1.z, r1.z
                  div r1.z, r1.z, r2.x
                  max r1.z, r1.z, l(0.000000)
                  min r1.z, r1.z, l(1.000000)  // GetKnot<0:[0f,1f]>
                
                #line 228
                  mov r1.z, r1.z  // gKK1<0:[0f,1f]>
                  nop 
                  iadd r3.y, r0.z, l(2)  // i<0>
                
                #line 135
                  iadd r3.w, r3.y, l(-2)
                  itof r3.w, r3.w
                  div r3.w, r3.w, r2.x
                  max r3.w, r3.w, l(0.000000)
                  min r3.w, r3.w, l(1.000000)  // GetKnot<0:[0f,1f]>
                
                #line 229
                  mov r3.w, r3.w  // gKKJ<0:[0f,1f]>
                  nop 
                  iadd r3.y, r3.y, l(1)  // i<0>
                
                #line 135
                  iadd r3.y, r3.y, l(-2)
                  itof r3.y, r3.y
                  div r2.x, r3.y, r2.x
                  max r2.x, r2.x, l(0.000000)
                  min r2.x, r2.x, l(1.000000)  // GetKnot<0:[0f,1f]>
                
                #line 230
                  mov r2.x, r2.x  // gKKJ1<0:[0f,1f]>
                  mov r1.x, -r1.x
                  add r0.w, r0.w, r1.x
                  add r3.y, r1.x, r3.w
                  div r0.w, r0.w, r3.y  // c0V<0:NaN:Inf>
                  add r3.w, r7.y, r2.x
                  mov r1.z, -r1.z
                  add r1.z, r1.z, r2.x
                  div r3.w, r3.w, r1.z  // c1V<0:NaN:Inf>
                  mul r0.w, r7.w, r0.w
                  mul r3.w, r7.x, r3.w
                  add r0.w, r0.w, r3.w
                  mov x1[r0.z + 24].x, r0.w  // basisV[r0.z/3]<24:Inf>
                  add r0.w, r1.x, r1.y
                  div r0.w, r0.w, r3.y  // c0V_pdv<0:NaN:Inf>
                  add r1.x, r8.y, r2.x
                  div r1.x, r1.x, r1.z  // c1V_pdv<0:NaN:Inf>
                  mul r0.w, r6.y, r0.w
                  mul r1.x, r6.w, r1.x
                  add r0.w, r0.w, r1.x
                  mov x3[r0.z + 24].x, r0.w  // basisV_pdv[r0.z/3]<24:Inf>
                
                #line 225
                endif 
                
                #line 246
                ige r0.z, r1.w, r8.w
                not r0.w, r0.z
                if_nz r0.z
                
                #line 249
                  ige r0.z, r2.y, r4.z
                  not r1.x, r0.z
                  if_nz r0.z
                    mul r0.z, r3.x, r3.z
                    imad r1.y, r4.z, cb0[5].w, r8.w
                    mov r4.xyw, -cb0[107].xyxz
                    add r4.xyw, r4.xyxw, cb0[r1.y + 7].xyxz
                    mul r5.yzw, r0.zzzz, r4.xxyw
                    add r5.yzw, r5.yyzw, l(0.000000, 0.000000, 0.000000, 0.000000)  // pos<0:NaN:Inf,1:NaN:Inf,2:NaN:Inf>
                    mul r0.z, r2.z, r3.x
                    mul r6.xyz, r4.xywx, r0.zzzz
                    add r6.xyz, r6.xyzx, l(0.000000, 0.000000, 0.000000, 0.000000)  // pos_pdu<0:NaN:Inf,1:NaN:Inf,2:NaN:Inf>
                    mul r0.z, r2.w, r3.z
                    mul r4.xyw, r4.xyxw, r0.zzzz
                    add r4.xyw, r4.xyxw, l(0.000000, 0.000000, 0.000000, 0.000000)  // pos_pdv<0:NaN:Inf,1:NaN:Inf,2:NaN:Inf>
                    mov r0.z, r5.x  // jV<0>
                  else 
                    mov r5.yzw, l(0,0,0,0)  // pos<0: 0f,1: 0f,2: 0f>
                    mov r6.xyz, l(0,0,0,0)  // pos_pdu<0: 0f,1: 0f,2: 0f>
                    mov r4.xyw, l(0,0,0,0)  // pos_pdv<0: 0f,1: 0f,2: 0f>
                    mov r0.z, r4.z  // jV<0>
                  endif 
                  not r1.x, r1.x
                  ige r1.y, r2.y, r5.x
                  and r1.x, r1.x, r1.y
                  not r1.y, r1.x
                  if_nz r1.x
                    mov r1.x, r0.z
                    mov r1.z, x1[r1.x + 24].x  // basisV<24:NaN:Inf>
                    mul r2.x, r1.z, r3.z
                    imad r3.y, r0.z, cb0[5].w, r8.w
                    mov r7.xyz, -cb0[107].xyzx
                    add r7.xyz, r7.xyzx, cb0[r3.y + 7].xyzx
                    mul r8.xyz, r2.xxxx, r7.xyzx
                    add r5.yzw, r5.yyzw, r8.xxyz  // pos<0:NaN:Inf,1:NaN:Inf,2:NaN:Inf>
                    mul r1.z, r1.z, r2.z
                    mul r8.xyz, r7.xyzx, r1.zzzz
                    add r6.xyz, r6.xyzx, r8.xyzx  // pos_pdu<0:NaN:Inf,1:NaN:Inf,2:NaN:Inf>
                    mov r1.x, x3[r1.x + 24].x  // basisV_pdv<24:NaN:Inf>
                    mul r1.x, r1.x, r3.z
                    mul r7.xyz, r7.xyzx, r1.xxxx
                    add r4.xyw, r4.xyxw, r7.xyxz  // pos_pdv<0:NaN:Inf,1:NaN:Inf,2:NaN:Inf>
                
                #line 249
                    iadd r0.z, r0.z, l(1)  // jV<0>
                  endif 
                  iadd r1.x, r5.x, l(1)  // jV<0>
                  not r1.y, r1.y
                  ige r1.x, r2.y, r1.x
                  and r1.x, r1.y, r1.x
                  if_nz r1.x
                    mov r1.x, r0.z
                    mov r1.y, x1[r1.x + 24].x  // basisV<24:NaN:Inf>
                    mul r1.z, r1.y, r3.z
                    imad r0.z, r0.z, cb0[5].w, r8.w
                    mov r7.xyz, -cb0[107].xyzx
                    add r7.xyz, r7.xyzx, cb0[r0.z + 7].xyzx
                    mul r8.xyz, r1.zzzz, r7.xyzx
                    add r5.yzw, r5.yyzw, r8.xxyz  // pos<0:NaN:Inf,1:NaN:Inf,2:NaN:Inf>
                    mul r0.z, r1.y, r2.z
                    mul r8.xyz, r7.xyzx, r0.zzzz
                    add r6.xyz, r6.xyzx, r8.xyzx  // pos_pdu<0:NaN:Inf,1:NaN:Inf,2:NaN:Inf>
                    mov r0.z, x3[r1.x + 24].x  // basisV_pdv<24:NaN:Inf>
                    mul r0.z, r0.z, r3.z
                    mul r1.xyz, r7.xyzx, r0.zzzz
                    add r4.xyw, r1.xyxz, r4.xyxw  // pos_pdv<0:NaN:Inf,1:NaN:Inf,2:NaN:Inf>
                
                #line 249
                  endif 
                  mov r8.w, r9.x  // jU<0>
                
                #line 246
                else 
                  mov r5.yzw, l(0,0,0,0)  // pos<0: 0f,1: 0f,2: 0f>
                  mov r6.xyz, l(0,0,0,0)  // pos_pdu<0: 0f,1: 0f,2: 0f>
                  mov r4.xyw, l(0,0,0,0)  // pos_pdv<0: 0f,1: 0f,2: 0f>
                  mov r8.w, r8.w  // jU<0>
                endif 
                not r0.z, r0.w
                ige r0.w, r1.w, r9.x
                and r0.z, r0.z, r0.w
                not r0.w, r0.z
                if_nz r0.z
                
                #line 249
                  ige r0.z, r2.y, r4.z
                  not r1.x, r0.z
                  if_nz r0.z
                    mov r0.z, r8.w
                    mov r1.y, x0[r0.z + 24].x  // basisU<24:NaN:Inf>
                    mul r1.z, r3.x, r1.y
                    imad r2.x, r4.z, cb0[5].w, r8.w
                    mov r3.yzw, -cb0[107].xxyz
                    add r3.yzw, r3.yyzw, cb0[r2.x + 7].xxyz
                    mul r7.xyz, r1.zzzz, r3.yzwy
                    add r5.yzw, r5.yyzw, r7.xxyz  // pos<0:NaN:Inf,1:NaN:Inf,2:NaN:Inf>
                    mov r0.z, x2[r0.z + 24].x  // basisU_pdu<24:NaN:Inf>
                    mul r0.z, r3.x, r0.z
                    mul r7.xyz, r3.yzwy, r0.zzzz
                    add r6.xyz, r6.xyzx, r7.xyzx  // pos_pdu<0:NaN:Inf,1:NaN:Inf,2:NaN:Inf>
                    mul r0.z, r2.w, r1.y
                    mul r3.yzw, r3.yyzw, r0.zzzz
                    add r4.xyw, r3.yzyw, r4.xyxw  // pos_pdv<0:NaN:Inf,1:NaN:Inf,2:NaN:Inf>
                    mov r0.z, r5.x  // jV<0>
                  else 
                    mov r0.z, r4.z  // jV<0>
                  endif 
                  not r1.x, r1.x
                  ige r1.y, r2.y, r5.x
                  and r1.x, r1.x, r1.y
                  not r1.y, r1.x
                  if_nz r1.x
                    mov r1.x, r8.w
                    mov r1.z, x0[r1.x + 24].x  // basisU<24:NaN:Inf>
                    mov r2.x, r0.z
                    mov r2.z, x1[r2.x + 24].x  // basisV<24:NaN:Inf>
                    mul r3.y, r1.z, r2.z
                    imad r3.z, r0.z, cb0[5].w, r8.w
                    mov r7.xyz, -cb0[107].xyzx
                    add r7.xyz, r7.xyzx, cb0[r3.z + 7].xyzx
                    mul r3.yzw, r3.yyyy, r7.xxyz
                    add r5.yzw, r3.yyzw, r5.yyzw  // pos<0:NaN:Inf,1:NaN:Inf,2:NaN:Inf>
                    mov r1.x, x2[r1.x + 24].x  // basisU_pdu<24:NaN:Inf>
                    mul r1.x, r2.z, r1.x
                    mul r3.yzw, r7.xxyz, r1.xxxx
                    add r6.xyz, r3.yzwy, r6.xyzx  // pos_pdu<0:NaN:Inf,1:NaN:Inf,2:NaN:Inf>
                    mov r1.x, x3[r2.x + 24].x  // basisV_pdv<24:NaN:Inf>
                    mul r1.x, r1.x, r1.z
                    mul r3.yzw, r7.xxyz, r1.xxxx
                    add r4.xyw, r3.yzyw, r4.xyxw  // pos_pdv<0:NaN:Inf,1:NaN:Inf,2:NaN:Inf>
                
                #line 249
                    iadd r0.z, r0.z, l(1)  // jV<0>
                  endif 
                  iadd r1.x, r5.x, l(1)  // jV<0>
                  not r1.y, r1.y
                  ige r1.x, r2.y, r1.x
                  and r1.x, r1.y, r1.x
                  if_nz r1.x
                    mov r1.x, r8.w
                    mov r1.y, x0[r1.x + 24].x  // basisU<24:NaN:Inf>
                    mov r1.z, r0.z
                    mov r2.x, x1[r1.z + 24].x  // basisV<24:NaN:Inf>
                    mul r2.z, r1.y, r2.x
                    imad r0.z, r0.z, cb0[5].w, r8.w
                    mov r3.yzw, -cb0[107].xxyz
                    add r3.yzw, r3.yyzw, cb0[r0.z + 7].xxyz
                    mul r7.xyz, r2.zzzz, r3.yzwy
                    add r5.yzw, r5.yyzw, r7.xxyz  // pos<0:NaN:Inf,1:NaN:Inf,2:NaN:Inf>
                    mov r0.z, x2[r1.x + 24].x  // basisU_pdu<24:NaN:Inf>
                    mul r0.z, r2.x, r0.z
                    mul r7.xyz, r3.yzwy, r0.zzzz
                    add r6.xyz, r6.xyzx, r7.xyzx  // pos_pdu<0:NaN:Inf,1:NaN:Inf,2:NaN:Inf>
                    mov r0.z, x3[r1.z + 24].x  // basisV_pdv<24:NaN:Inf>
                    mul r0.z, r0.z, r1.y
                    mul r1.xyz, r3.yzwy, r0.zzzz
                    add r4.xyw, r1.xyxz, r4.xyxw  // pos_pdv<0:NaN:Inf,1:NaN:Inf,2:NaN:Inf>
                
                #line 249
                  endif 
                
                #line 246
                  iadd r8.w, r8.w, l(1)  // jU<0>
                endif 
                iadd r0.z, r9.x, l(1)  // jU<0>
                not r0.w, r0.w
                ige r0.z, r1.w, r0.z
                and r0.z, r0.w, r0.z
                if_nz r0.z
                
                #line 249
                  ige r0.z, r2.y, r4.z
                  not r0.w, r0.z
                  if_nz r0.z
                    mov r0.z, r8.w
                    mov r1.x, x0[r0.z + 24].x  // basisU<24:NaN:Inf>
                    mul r1.y, r3.x, r1.x
                    imad r1.z, r4.z, cb0[5].w, r8.w
                    mov r3.yzw, -cb0[107].xxyz
                    add r3.yzw, r3.yyzw, cb0[r1.z + 7].xxyz
                    mul r1.yzw, r1.yyyy, r3.yyzw
                    add r5.yzw, r1.yyzw, r5.yyzw  // pos<0:NaN:Inf,1:NaN:Inf,2:NaN:Inf>
                    mov r0.z, x2[r0.z + 24].x  // basisU_pdu<24:NaN:Inf>
                    mul r0.z, r3.x, r0.z
                    mul r1.yzw, r3.yyzw, r0.zzzz
                    add r6.xyz, r1.yzwy, r6.xyzx  // pos_pdu<0:NaN:Inf,1:NaN:Inf,2:NaN:Inf>
                    mul r0.z, r2.w, r1.x
                    mul r1.xyz, r3.yzwy, r0.zzzz
                    add r4.xyw, r1.xyxz, r4.xyxw  // pos_pdv<0:NaN:Inf,1:NaN:Inf,2:NaN:Inf>
                    mov r4.z, r5.x  // jV<0>
                  else 
                    mov r4.z, r4.z  // jV<0>
                  endif 
                  not r0.z, r0.w
                  ige r0.w, r2.y, r5.x
                  and r0.z, r0.z, r0.w
                  not r0.w, r0.z
                  if_nz r0.z
                    mov r0.z, r8.w
                    mov r1.x, x0[r0.z + 24].x  // basisU<24:NaN:Inf>
                    mov r1.y, r4.z
                    mov r1.z, x1[r1.y + 24].x  // basisV<24:NaN:Inf>
                    mul r1.w, r1.z, r1.x
                    imad r2.x, r4.z, cb0[5].w, r8.w
                    mov r3.xyz, -cb0[107].xyzx
                    add r2.xzw, r3.xxyz, cb0[r2.x + 7].xxyz
                    mul r3.xyz, r1.wwww, r2.xzwx
                    add r5.yzw, r3.xxyz, r5.yyzw  // pos<0:NaN:Inf,1:NaN:Inf,2:NaN:Inf>
                    mov r0.z, x2[r0.z + 24].x  // basisU_pdu<24:NaN:Inf>
                    mul r0.z, r1.z, r0.z
                    mul r3.xyz, r2.xzwx, r0.zzzz
                    add r6.xyz, r3.xyzx, r6.xyzx  // pos_pdu<0:NaN:Inf,1:NaN:Inf,2:NaN:Inf>
                    mov r0.z, x3[r1.y + 24].x  // basisV_pdv<24:NaN:Inf>
                    mul r0.z, r0.z, r1.x
                    mul r1.xyz, r2.xzwx, r0.zzzz
                    add r4.xyw, r1.xyxz, r4.xyxw  // pos_pdv<0:NaN:Inf,1:NaN:Inf,2:NaN:Inf>
                
                #line 249
                    iadd r4.z, r4.z, l(1)  // jV<0>
                  endif 
                  iadd r0.z, r5.x, l(1)  // jV<0>
                  not r0.w, r0.w
                  ige r0.z, r2.y, r0.z
                  and r0.z, r0.w, r0.z
                  if_nz r0.z
                    mov r0.z, r8.w
                    mov r0.w, x0[r0.z + 24].x  // basisU<24:NaN:Inf>
                    mov r1.x, r4.z
                    mov r1.y, x1[r1.x + 24].x  // basisV<24:NaN:Inf>
                    mul r1.z, r0.w, r1.y
                    imad r1.w, r4.z, cb0[5].w, r8.w
                    mov r2.xyz, -cb0[107].xyzx
                    add r2.xyz, r2.xyzx, cb0[r1.w + 7].xyzx
                    mul r3.xyz, r1.zzzz, r2.xyzx
                    add r5.yzw, r3.xxyz, r5.yyzw  // pos<0:NaN:Inf,1:NaN:Inf,2:NaN:Inf>
                    mov r0.z, x2[r0.z + 24].x  // basisU_pdu<24:NaN:Inf>
                    mul r0.z, r1.y, r0.z
                    mul r1.yzw, r2.xxyz, r0.zzzz
                    add r6.xyz, r1.yzwy, r6.xyzx  // pos_pdu<0:NaN:Inf,1:NaN:Inf,2:NaN:Inf>
                    mov r0.z, x3[r1.x + 24].x  // basisV_pdv<24:NaN:Inf>
                    mul r0.z, r0.z, r0.w
                    mul r1.xyz, r2.xyzx, r0.zzzz
                    add r4.xyw, r1.xyxz, r4.xyxw  // pos_pdv<0:NaN:Inf,1:NaN:Inf,2:NaN:Inf>
                
                #line 249
                  endif 
                
                #line 246
                endif 
                
                #line 257
                mov r1.xyz, -r5.wyzw
                add r1.xyz, r1.xyzx, r6.zxyz
                dp3 r0.z, r1.xyzx, r1.xyzx
                rsq r0.z, r0.z
                mul r1.xyz, r0.zzzz, r1.xyzx  // tan<2:NaN:Inf,0:NaN:Inf,1:NaN:Inf>
                mov r2.xyz, -r5.zwyz
                add r2.xyz, r2.xyzx, r4.ywxy
                dp3 r0.z, r2.xyzx, r2.xyzx
                rsq r0.z, r0.z
                mul r2.xyz, r0.zzzz, r2.xyzx  // bTan<1:NaN:Inf,2:NaN:Inf,0:NaN:Inf>
                mul r3.xyz, r1.zxyz, r2.yzxy
                mul r1.xyz, r1.xyzx, r2.xyzx
                mov r1.xyz, -r1.xyzx
                add r1.xyz, r1.xyzx, r3.xyzx
                dp3 r0.z, r1.xyzx, r1.xyzx
                rsq r0.z, r0.z
                mul r1.xyz, r0.zzzz, r1.xyzx  // normal<0:NaN:Inf,1:NaN:Inf,2:NaN:Inf>
                add r2.xyz, r5.yzwy, cb0[107].xyzx  // pos<0:NaN:Inf,1:NaN:Inf,2:NaN:Inf>
                
                #line 56 "CPSurfaces-FinalComplete.fx"
                mov r2.xyz, r2.xyzx  // dout<0:NaN:Inf,1:NaN:Inf,2:NaN:Inf>
                mov r1.xyz, r1.xyzx  // dout<3:NaN:Inf,4:NaN:Inf,5:NaN:Inf>
                
                #line 60
                mov o0.xyz, r2.xyzx  // DS_FinalComplete<0:NaN:Inf,1:NaN:Inf,2:NaN:Inf>
                mov o1.xyz, r1.xyzx  // DS_FinalComplete<3:NaN:Inf,4:NaN:Inf,5:NaN:Inf>
                mov o2.xy, r0.xyxx  // DS_FinalComplete<6:NaN:Inf,7:NaN:Inf>
                ret 
                // Approximately 565 instruction slots used
                            
            };
            GeometryShader = asm {
                //
                // Generated by Microsoft (R) HLSL Shader Compiler 9.29.952.3111
                //
                //
                // Buffer Definitions: 
                //
                // cbuffer cbPerObject
                // {
                //
                //   float4x4 gViewProj;                // Offset:    0 Size:    64
                //   float3 gEyePosW;                   // Offset:   64 Size:    12 [unused]
                //   float gMaxTessDistance;            // Offset:   76 Size:     4 [unused]
                //   float gMinTessDistance;            // Offset:   80 Size:     4 [unused]
                //   float gMinTessFactor;              // Offset:   84 Size:     4 [unused]
                //   float gMaxTessFactor;              // Offset:   88 Size:     4 [unused]
                //   int gNU;                           // Offset:   92 Size:     4 [unused]
                //   int gNV;                           // Offset:   96 Size:     4 [unused]
                //   float4 gCP[100];                   // Offset:  112 Size:  1600 [unused]
                //   float3 gCenter;                    // Offset: 1712 Size:    12 [unused]
                //
                // }
                //
                // cbuffer cbPerObjectAdditional
                // {
                //
                //   struct DirectionalLight
                //   {
                //       
                //       float4 Ambient;                // Offset:    0
                //       float4 Diffuse;                // Offset:   16
                //       float4 Specular;               // Offset:   32
                //       float3 Direction;              // Offset:   48
                //       float Pad;                     // Offset:   60
                //
                //   } gDirLight;                       // Offset:    0 Size:    64 [unused]
                //   
                //   struct Material
                //   {
                //       
                //       float4 Ambient;                // Offset:   64
                //       float4 Diffuse;                // Offset:   80
                //       float4 Specular;               // Offset:   96
                //       float4 Reflect;                // Offset:  112
                //
                //   } gMaterial;                       // Offset:   64 Size:    64 [unused]
                //   float4x4 gShadowTransform;         // Offset:  128 Size:    64
                //   float gShadowMapSize;              // Offset:  192 Size:     4 [unused]
                //
                // }
                //
                //
                // Resource Bindings:
                //
                // Name                                 Type  Format         Dim Slot Elements
                // ------------------------------ ---------- ------- ----------- ---- --------
                // cbPerObject                       cbuffer      NA          NA    0        1
                // cbPerObjectAdditional             cbuffer      NA          NA    1        1
                //
                //
                //
                // Input signature:
                //
                // Name                 Index   Mask Register SysValue Format   Used
                // -------------------- ----- ------ -------- -------- ------ ------
                // POSTION                  0   xyz         0     NONE  float   xyz 
                // NORMAL                   0   xyz         1     NONE  float   xyz 
                // TEXCOORD                 0   xy          2     NONE  float   xy  
                //
                //
                // Output signature:
                //
                // Name                 Index   Mask Register SysValue Format   Used
                // -------------------- ----- ------ -------- -------- ------ ------
                // m0:SV_POSITION           0   xyzw        0      POS  float   xyzw
                // m0:NORMAL                0   xyz         1     NONE  float   xyz 
                // m0:TEXCOORD              0   xy          2     NONE  float   xy  
                // m0:TEXCOORD              1   xyzw        3     NONE  float   xyzw
                //
                gs_5_0
                dcl_globalFlags refactoringAllowed
                dcl_constantbuffer cb0[4], immediateIndexed
                dcl_constantbuffer cb1[12], immediateIndexed
                dcl_input v[3][0].xyz
                dcl_input v[3][1].xyz
                dcl_input v[3][2].xy
                dcl_temps 7
                dcl_inputprimitive triangle 
                dcl_stream m0
                dcl_outputtopology trianglestrip 
                dcl_output_siv o0.xyzw, position
                dcl_output o1.xyz
                dcl_output o2.xy
                dcl_output o3.xyzw
                dcl_maxout 3
                
                #line 72 "CPSurfaces-FinalComplete.fx"
                mov r0.xyz, v[0][0].xyzx
                mov r0.w, l(1.000000)
                dp4 r1.x, r0.xyzw, cb0[0].xyzw
                dp4 r1.y, r0.xyzw, cb0[1].xyzw
                dp4 r1.z, r0.xyzw, cb0[2].xyzw
                dp4 r1.w, r0.xyzw, cb0[3].xyzw
                
                #line 75
                dp4 r2.x, r0.xyzw, cb1[8].xyzw
                dp4 r2.y, r0.xyzw, cb1[9].xyzw
                dp4 r2.z, r0.xyzw, cb1[10].xyzw
                dp4 r0.x, r0.xyzw, cb1[11].xyzw
                
                #line 72
                mov r3.xyz, v[1][0].xyzx
                mov r3.w, l(1.000000)
                dp4 r0.y, r3.xyzw, cb0[0].xyzw
                dp4 r0.z, r3.xyzw, cb0[1].xyzw
                dp4 r0.w, r3.xyzw, cb0[2].xyzw
                dp4 r2.w, r3.xyzw, cb0[3].xyzw
                
                #line 75
                dp4 r4.x, r3.xyzw, cb1[8].xyzw
                dp4 r4.y, r3.xyzw, cb1[9].xyzw
                dp4 r4.z, r3.xyzw, cb1[10].xyzw
                dp4 r3.x, r3.xyzw, cb1[11].xyzw
                
                #line 72
                mov r5.xyz, v[2][0].xyzx
                mov r5.w, l(1.000000)
                dp4 r3.y, r5.xyzw, cb0[0].xyzw
                dp4 r3.z, r5.xyzw, cb0[1].xyzw
                dp4 r3.w, r5.xyzw, cb0[2].xyzw
                dp4 r4.w, r5.xyzw, cb0[3].xyzw
                
                #line 75
                dp4 r6.x, r5.xyzw, cb1[8].xyzw
                dp4 r6.y, r5.xyzw, cb1[9].xyzw
                dp4 r6.z, r5.xyzw, cb1[10].xyzw
                dp4 r5.x, r5.xyzw, cb1[11].xyzw
                
                #line 78
                mov o0.x, r1.x  // triStream<0>
                mov o0.y, r1.y  // triStream<0>
                mov o0.z, r1.z  // triStream<0>
                mov o0.w, r1.w  // triStream<0>
                mov o1.xyz, v[0][1].xyzx  // triStream<0,0,0>
                mov o2.xy, v[0][2].xyxx  // triStream<0,0>
                mov o3.x, r2.x  // triStream<0>
                mov o3.y, r2.y  // triStream<0>
                mov o3.z, r2.z  // triStream<0>
                mov o3.w, r0.x  // triStream<0>
                emit_stream m0
                mov o0.x, r0.y  // triStream<0>
                mov o0.y, r0.z  // triStream<0>
                mov o0.z, r0.w  // triStream<0>
                mov o0.w, r2.w  // triStream<0>
                mov o1.xyz, v[1][1].xyzx  // triStream<0,0,0>
                mov o2.xy, v[1][2].xyxx  // triStream<0,0>
                mov o3.x, r4.x  // triStream<0>
                mov o3.y, r4.y  // triStream<0>
                mov o3.z, r4.z  // triStream<0>
                mov o3.w, r3.x  // triStream<0>
                emit_stream m0
                mov o0.x, r3.y  // triStream<0>
                mov o0.y, r3.z  // triStream<0>
                mov o0.z, r3.w  // triStream<0>
                mov o0.w, r4.w  // triStream<0>
                mov o1.xyz, v[2][1].xyzx  // triStream<0,0,0>
                mov o2.xy, v[2][2].xyxx  // triStream<0,0>
                mov o3.x, r6.x  // triStream<0>
                mov o3.y, r6.y  // triStream<0>
                mov o3.z, r6.z  // triStream<0>
                mov o3.w, r5.x  // triStream<0>
                emit_stream m0
                
                #line 64
                ret 
                // Approximately 64 instruction slots used
                            
            };
            PixelShader = asm {
                //
                // Generated by Microsoft (R) HLSL Shader Compiler 9.29.952.3111
                //
                //
                // Buffer Definitions: 
                //
                // cbuffer cbPerObjectAdditional
                // {
                //
                //   struct DirectionalLight
                //   {
                //       
                //       float4 Ambient;                // Offset:    0
                //       float4 Diffuse;                // Offset:   16
                //       float4 Specular;               // Offset:   32
                //       float3 Direction;              // Offset:   48
                //       float Pad;                     // Offset:   60
                //
                //   } gDirLight;                       // Offset:    0 Size:    64
                //   
                //   struct Material
                //   {
                //       
                //       float4 Ambient;                // Offset:   64
                //       float4 Diffuse;                // Offset:   80
                //       float4 Specular;               // Offset:   96
                //       float4 Reflect;                // Offset:  112
                //
                //   } gMaterial;                       // Offset:   64 Size:    64
                //   float4x4 gShadowTransform;         // Offset:  128 Size:    64 [unused]
                //   float gShadowMapSize;              // Offset:  192 Size:     4
                //
                // }
                //
                //
                // Resource Bindings:
                //
                // Name                                 Type  Format         Dim Slot Elements
                // ------------------------------ ---------- ------- ----------- ---- --------
                // samAnisotropic                    sampler      NA          NA    0        1
                // samShadow                       sampler_c      NA          NA    1        1
                // gDiffuseMap                       texture  float4          2d    0        1
                // gShadowMap                        texture  float4          2d    1        1
                // cbPerObjectAdditional             cbuffer      NA          NA    0        1
                //
                //
                //
                // Input signature:
                //
                // Name                 Index   Mask Register SysValue Format   Used
                // -------------------- ----- ------ -------- -------- ------ ------
                // SV_POSITION              0   xyzw        0      POS  float       
                // NORMAL                   0   xyz         1     NONE  float   xyz 
                // TEXCOORD                 0   xy          2     NONE  float   xy  
                // TEXCOORD                 1   xyzw        3     NONE  float   xyzw
                // SV_IsFrontFace           0   x           4    FFACE   uint   x   
                //
                //
                // Output signature:
                //
                // Name                 Index   Mask Register SysValue Format   Used
                // -------------------- ----- ------ -------- -------- ------ ------
                // SV_Target                0   xyzw        0   TARGET  float   xyzw
                //
                ps_5_0
                dcl_globalFlags refactoringAllowed
                dcl_constantbuffer cb0[13], immediateIndexed
                dcl_sampler s0, mode_default
                dcl_sampler s1, mode_comparison
                dcl_resource_texture2d (float,float,float,float) t0
                dcl_resource_texture2d (float,float,float,float) t1
                dcl_input_ps linear v1.xyz
                dcl_input_ps linear v2.xy
                dcl_input_ps linear v3.xyzw
                dcl_input_ps_sgv v4.x, is_front_face
                dcl_output o0.xyzw
                dcl_temps 6
                
                #line 86 "CPSurfaces-FinalComplete.fx"
                dp3 r0.x, v1.xyzx, v1.xyzx
                rsq r0.x, r0.x
                mul r0.xyz, r0.xxxx, v1.xyzx  // pin<4:NaN:Inf,5:NaN:Inf,6:NaN:Inf>
                if_z v4.x
                  mov r0.xyz, -r0.xyzx  // pin<4:NaN:Inf,5:NaN:Inf,6:NaN:Inf>
                endif 
                
                #line 96
                nop 
                mov r1.xyzw, v3.xyzw  // shadowPosH<0,1,2,3>
                mov r0.w, cb0[12].x  // sMapSize<0>
                
                #line 276 "LightsUtilities.fx"
                div r1.xyz, r1.zxyz, r1.wwww  // shadowPosH<2:NaN:Inf,0:NaN:Inf,1:NaN:Inf>
                
                #line 279
                mov r1.x, r1.x  // depth<0:NaN:Inf>
                
                #line 282
                div r2.y, l(1.000000), r0.w  // dx<0:Inf>
                mov r0.w, r2.y  // dx<0:Inf>
                
                #line 289
                mov r3.y, -r0.w  // offsets<3:Inf>
                mov r2.z, -r0.w  // offsets<5:Inf>
                mov r4.x, -r0.w  // offsets<6:Inf>
                mov r2.x, -r0.w  // offsets<12:Inf>
                
                #line 296
                mov r0.w, -r0.w
                add r3.zw, r0.wwww, r1.yyyz
                sample_c_lz_indexable(texture2d)(float,float,float,float) r0.w, r3.zwzz, t1.xxxx, s1, r1.x
                add r0.w, r0.w, l(0.000000)  // percentLit<0:[0f,1f]>
                mov r3.x, l(0)
                add r3.xy, r1.yzyy, r3.xyxx
                sample_c_lz_indexable(texture2d)(float,float,float,float) r1.w, r3.xyxx, t1.xxxx, s1, r1.x
                add r0.w, r0.w, r1.w  // percentLit<0:[0f,2f]>
                add r3.xy, r1.yzyy, r2.yzyy
                sample_c_lz_indexable(texture2d)(float,float,float,float) r1.w, r3.xyxx, t1.xxxx, s1, r1.x
                add r0.w, r0.w, r1.w  // percentLit<0:[0f,3f]>
                mov r4.y, l(0)
                add r3.xy, r1.yzyy, r4.xyxx
                sample_c_lz_indexable(texture2d)(float,float,float,float) r1.w, r3.xyxx, t1.xxxx, s1, r1.x
                add r0.w, r0.w, r1.w  // percentLit<0:[0f,4f]>
                add r3.xy, r1.yzyy, l(0.000000, 0.000000, 0.000000, 0.000000)
                sample_c_lz_indexable(texture2d)(float,float,float,float) r1.w, r3.xyxx, t1.xxxx, s1, r1.x
                add r0.w, r0.w, r1.w  // percentLit<0:[0f,5f]>
                mov r2.w, l(0)
                add r3.xy, r1.yzyy, r2.ywyy
                sample_c_lz_indexable(texture2d)(float,float,float,float) r1.w, r3.xyxx, t1.xxxx, s1, r1.x
                add r0.w, r0.w, r1.w  // percentLit<0:[0f,6f]>
                add r2.xz, r1.yyzy, r2.xxyx
                sample_c_lz_indexable(texture2d)(float,float,float,float) r1.w, r2.xzxx, t1.xxxx, s1, r1.x
                add r0.w, r0.w, r1.w  // percentLit<0:[0f,7f]>
                add r2.xz, r1.yyzy, r2.wwyw
                sample_c_lz_indexable(texture2d)(float,float,float,float) r1.w, r2.xzxx, t1.xxxx, s1, r1.x
                add r0.w, r0.w, r1.w  // percentLit<0:[0f,8f]>
                add r1.yz, r1.yyzy, r2.yyyy
                sample_c_lz_indexable(texture2d)(float,float,float,float) r1.x, r1.yzyy, t1.xxxx, s1, r1.x
                add r0.w, r0.w, r1.x  // percentLit<0:[0f,9f]>
                
                #line 299
                div r0.w, r0.w, l(9.000000)  // percentLit<0:[0f,1f]>
                mov r0.w, r0.w  // CalcShadowFactor<0:[0f,1f]>
                
                #line 96 "CPSurfaces-FinalComplete.fx"
                mov r0.w, r0.w  // shadow<0:[0f,1f]>
                
                #line 106
                nop 
                mov r1.xyz, cb0[4].xyzx  // mat<0,1,2>
                mov r2.xyz, cb0[5].xyzx  // mat<4,5,6>
                mov r3.xyz, cb0[0].xyzx  // L<0,1,2>
                mov r4.xyz, cb0[1].xyzx  // L<4,5,6>
                mov r5.xyz, cb0[3].xyzx  // L<12,13,14>
                mov r0.xyz, r0.xyzx  // normal<0:NaN:Inf,1:NaN:Inf,2:NaN:Inf>
                
                #line 119 "LightsUtilities.fx"
                mov r5.xyz, -r5.xyzx  // lightVec<0,1,2>
                
                #line 122
                mul r1.xyz, r1.xyzx, r3.xyzx  // ambient<0:Inf,1:Inf,2:Inf>
                
                #line 127
                dp3 r0.x, r5.xyzx, r0.xyzx  // diffuseFactor<0:NaN:Inf>
                
                #line 131
                lt r0.y, l(0.000000), r0.x
                
                #line 136
                mul r2.xyz, r2.xyzx, r0.xxxx
                mul r2.xyz, r4.xyzx, r2.xyzx  // diffuse<0:NaN:Inf,1:NaN:Inf,2:NaN:Inf>
                
                #line 131
                movc r0.xyz, r0.yyyy, r2.xyzx, l(0,0,0,0)  // diffuse<0:NaN:Inf,1:NaN:Inf,2:NaN:Inf>
                
                #line 106 "CPSurfaces-FinalComplete.fx"
                mov r1.xyz, r1.xyzx  // lA<0:Inf,1:Inf,2:Inf>
                mov r0.xyz, r0.xyzx  // lD<0:NaN:Inf,1:NaN:Inf,2:NaN:Inf>
                add r1.xyz, r1.xyzx, l(0.000000, 0.000000, 0.000000, 0.000000)  // ambient<0:Inf,1:Inf,2:Inf>
                mul r0.xyz, r0.wwww, r0.xyzx
                add r0.xyz, r0.xyzx, l(0.000000, 0.000000, 0.000000, 0.000000)  // diffuse<0:NaN:Inf,1:NaN:Inf,2:NaN:Inf>
                
                #line 111
                sample_indexable(texture2d)(float,float,float,float) r2.xyzw, v2.xyxx, t0.xyzw, s0  // texColor<0:Inf,1:Inf,2:Inf,3:Inf>
                add r0.w, r2.w, l(-0.150000)
                lt r0.w, r0.w, l(0.000000)
                and r0.w, r0.w, l(-1)
                discard r0.w
                add r0.xyz, r0.xyzx, r1.xyzx
                mul r0.xyz, r0.xyzx, r2.xyzx
                add r0.xyz, r0.xyzx, l(0.000000, 0.000000, 0.000000, 0.000000)  // litColor<0:NaN:Inf,1:NaN:Inf,2:NaN:Inf>
                
                #line 116
                mul r0.w, r2.w, cb0[5].w  // litColor<3:NaN:Inf>
                mov o0.xyz, r0.xyzx  // PS_FinalComplete<0:NaN:Inf,1:NaN:Inf,2:NaN:Inf>
                mov o0.w, r0.w  // PS_FinalComplete<3:NaN:Inf>
                ret 
                // Approximately 82 instruction slots used
                            
            };
            RasterizerState = NoCulling;
        }

    }

    technique11 BSplineDraw_DepthOnly
    {
        pass P0
        {
            VertexShader = asm {
                //
                // Generated by Microsoft (R) HLSL Shader Compiler 9.29.952.3111
                //
                //
                //
                // Input signature:
                //
                // Name                 Index   Mask Register SysValue Format   Used
                // -------------------- ----- ------ -------- -------- ------ ------
                // TEXCOORD                 0   xy          0     NONE  float   xy  
                //
                //
                // Output signature:
                //
                // Name                 Index   Mask Register SysValue Format   Used
                // -------------------- ----- ------ -------- -------- ------ ------
                // TEXCOORD                 0   xy          0     NONE  float   xy  
                //
                vs_5_0
                dcl_globalFlags refactoringAllowed
                dcl_input v0.xy
                dcl_output o0.xy
                dcl_temps 1
                
                #line 11 "CPSurfaces-FinalComplete.fx"
                mov r0.xy, v0.xyxx  // vout<0,1>
                mov o0.xy, r0.xyxx  // VS<0,1>
                ret 
                // Approximately 3 instruction slots used
                            
            };
            HullShader = asm {
                //
                // Generated by Microsoft (R) HLSL Shader Compiler 9.29.952.3111
                //
                //
                // Buffer Definitions: 
                //
                // cbuffer cbPerObject
                // {
                //
                //   float4x4 gViewProj;                // Offset:    0 Size:    64 [unused]
                //   float3 gEyePosW;                   // Offset:   64 Size:    12
                //   float gMaxTessDistance;            // Offset:   76 Size:     4
                //   float gMinTessDistance;            // Offset:   80 Size:     4
                //   float gMinTessFactor;              // Offset:   84 Size:     4
                //   float gMaxTessFactor;              // Offset:   88 Size:     4
                //   int gNU;                           // Offset:   92 Size:     4 [unused]
                //   int gNV;                           // Offset:   96 Size:     4 [unused]
                //   float4 gCP[100];                   // Offset:  112 Size:  1600 [unused]
                //   float3 gCenter;                    // Offset: 1712 Size:    12
                //
                // }
                //
                //
                // Resource Bindings:
                //
                // Name                                 Type  Format         Dim Slot Elements
                // ------------------------------ ---------- ------- ----------- ---- --------
                // cbPerObject                       cbuffer      NA          NA    0        1
                //
                //
                //
                // Patch Constant signature:
                //
                // Name                 Index   Mask Register SysValue Format   Used
                // -------------------- ----- ------ -------- -------- ------ ------
                // SV_TessFactor            0   x           0  TRIEDGE  float   x   
                // SV_TessFactor            1   x           1  TRIEDGE  float   x   
                // SV_TessFactor            2   x           2  TRIEDGE  float   x   
                // SV_InsideTessFactor      0   x           3   TRIINT  float   x   
                //
                //
                // Input signature:
                //
                // Name                 Index   Mask Register SysValue Format   Used
                // -------------------- ----- ------ -------- -------- ------ ------
                // TEXCOORD                 0   xy          0     NONE  float   xy  
                //
                //
                // Output signature:
                //
                // Name                 Index   Mask Register SysValue Format   Used
                // -------------------- ----- ------ -------- -------- ------ ------
                // TEXCOORD                 0   xy          0     NONE  float   xy  
                //
                // Tessellation Domain   # of control points
                // -------------------- --------------------
                // Triangle                                3
                //
                // Tessellation Output Primitive  Partitioning Type 
                // ------------------------------ ------------------
                // Clockwise Triangles            Integer           
                //
                hs_5_0
                hs_decls 
                dcl_input_control_point_count 3
                dcl_output_control_point_count 3
                dcl_tessellator_domain domain_tri
                dcl_tessellator_partitioning partitioning_integer
                dcl_tessellator_output_primitive output_triangle_cw
                dcl_hs_max_tessfactor l(64.000000)
                dcl_globalFlags refactoringAllowed
                dcl_constantbuffer cb0[108], immediateIndexed
                
                #line 44 "CPSurfaces-FinalComplete.fx"
                hs_control_point_phase 
                dcl_input vOutputControlPointID
                dcl_input v[3][0].xy
                dcl_output o0.xy
                dcl_temps 1
                mov r0.x, vOutputControlPointID  // hout<0,1>
                mov r0.xy, v[r0.x + 0][0].xyxx  // HS<0,1>
                mov o0.xy, r0.xyxx
                
                #line 26
                ret 
                hs_join_phase   // p<0,1,2>
                dcl_output_siv o0.x, finalTriUeq0EdgeTessFactor
                dcl_output_siv o1.x, finalTriVeq0EdgeTessFactor
                dcl_output_siv o2.x, finalTriWeq0EdgeTessFactor
                dcl_output_siv o3.x, finalTriInsideTessFactor
                dcl_temps 2
                
                #line 85 "CPSurfaces-Utilities.fx"
                nop 
                mov r0.xyz, cb0[107].xyzx
                mov r1.xyz, -cb0[4].xyzx
                add r0.xyz, r0.xyzx, r1.xyzx  // d<0:NaN:Inf>
                dp3 r0.x, r0.xyzx, r0.xyzx
                sqrt r0.x, r0.x
                mov r0.y, -cb0[5].x
                add r0.x, r0.y, r0.x
                add r0.y, r0.y, cb0[4].w
                div r0.x, r0.x, r0.y  // s<0:[0f,1f]>
                max r0.x, r0.x, l(0.000000)
                min r0.x, r0.x, l(1.000000)
                log r0.x, r0.x
                mul r0.x, r0.x, l(1.500000)
                exp r0.x, r0.x
                mov r0.y, -cb0[5].y
                add r0.y, r0.y, cb0[5].z  // CalcTessFactor<0:NaN:Inf>
                
                #line 26 "CPSurfaces-FinalComplete.fx"
                mul r0.x, r0.y, r0.x  // tess<0:NaN:Inf>
                add r0.w, r0.x, cb0[5].y  // pt<0:NaN:Inf>
                
                #line 32
                mov r0.w, r0.w  // ConstantHS<0:NaN:Inf>
                mov r0.w, r0.w  // ConstantHS<1:NaN:Inf>
                mov r0.x, r0.w  // ConstantHS<2:NaN:Inf>
                mov r0.y, r0.w  // ConstantHS<3:NaN:Inf>
                mov r0.z, r0.w  // ConstantHS<0:Inf:[-1.#INFf,64f],1:Inf:[-1.#INFf,64f],2:Inf:[-1.#INFf,64f],3:Inf:[-1.#INFf,64f]>
                mov r0.w, r0.w  // ConstantHS<0:Inf:[-1.#INFf,64f]>
                min r0.xyzw, r0.xyzw, l(64.000000, 64.000000, 64.000000, 64.000000)  // ConstantHS<1:Inf:[-1.#INFf,64f]>
                mov o0.x, r0.x  // ConstantHS<2:Inf:[-1.#INFf,64f]>
                mov o1.x, r0.y  // ConstantHS<3:Inf:[-1.#INFf,64f]>
                mov o2.x, r0.z
                
                // incorrect instruction offset in debug info
                mov o3.x, r0.w
                // incorrect instruction offset in debug info
                
                
                // incorrect instruction offset in debug info
                ret 
                // incorrect instruction offset in debug info
                
                // Approximately 35 instruction slots used
                            
            };
            DomainShader = asm {
                //
                // Generated by Microsoft (R) HLSL Shader Compiler 9.29.952.3111
                //
                //
                // Buffer Definitions: 
                //
                // cbuffer cbPerObject
                // {
                //
                //   float4x4 gViewProj;                // Offset:    0 Size:    64 [unused]
                //   float3 gEyePosW;                   // Offset:   64 Size:    12 [unused]
                //   float gMaxTessDistance;            // Offset:   76 Size:     4 [unused]
                //   float gMinTessDistance;            // Offset:   80 Size:     4 [unused]
                //   float gMinTessFactor;              // Offset:   84 Size:     4 [unused]
                //   float gMaxTessFactor;              // Offset:   88 Size:     4 [unused]
                //   int gNU;                           // Offset:   92 Size:     4
                //   int gNV;                           // Offset:   96 Size:     4
                //   float4 gCP[100];                   // Offset:  112 Size:  1600
                //   float3 gCenter;                    // Offset: 1712 Size:    12 [unused]
                //
                // }
                //
                //
                // Resource Bindings:
                //
                // Name                                 Type  Format         Dim Slot Elements
                // ------------------------------ ---------- ------- ----------- ---- --------
                // cbPerObject                       cbuffer      NA          NA    0        1
                //
                //
                //
                // Patch Constant signature:
                //
                // Name                 Index   Mask Register SysValue Format   Used
                // -------------------- ----- ------ -------- -------- ------ ------
                // SV_TessFactor            0   x           0  TRIEDGE  float       
                // SV_TessFactor            1   x           1  TRIEDGE  float       
                // SV_TessFactor            2   x           2  TRIEDGE  float       
                // SV_InsideTessFactor      0   x           3   TRIINT  float       
                //
                //
                // Input signature:
                //
                // Name                 Index   Mask Register SysValue Format   Used
                // -------------------- ----- ------ -------- -------- ------ ------
                // TEXCOORD                 0   xy          0     NONE  float   xy  
                //
                //
                // Output signature:
                //
                // Name                 Index   Mask Register SysValue Format   Used
                // -------------------- ----- ------ -------- -------- ------ ------
                // POSTION                  0   xyz         0     NONE  float   xyz 
                //
                // Tessellation Domain   # of control points
                // -------------------- --------------------
                // Triangle                                3
                //
                ds_5_0
                dcl_input_control_point_count 3
                dcl_tessellator_domain domain_tri
                dcl_globalFlags refactoringAllowed
                dcl_constantbuffer cb0[107], dynamicIndexed
                dcl_input vDomain.xyz
                dcl_input vicp[3][0].xy
                dcl_output o0.xyz
                dcl_temps 7
                dcl_indexableTemp x0[36], 4
                dcl_indexableTemp x1[36], 4
                
                #line 18 "CPSurfaces-NormalDepthTech.fx"
                mul r0.xy, vDomain.xxxx, vicp[0][0].xyxx
                mul r0.zw, vDomain.yyyy, vicp[1][0].xxxy
                add r0.xy, r0.zwzz, r0.xyxx
                mul r0.zw, vDomain.zzzz, vicp[2][0].xxxy
                add r0.xy, r0.zwzz, r0.xyxx  // texCoord<0:NaN:Inf,1:NaN:Inf>
                
                #line 21
                nop 
                mov r0.xy, r0.xyxx  // texCoord<0:NaN:Inf,1:NaN:Inf>
                
                #line 266 "CPSurfaces-Utilities.fx"
                mov r1.xyz, l(0,0,0,0)  // pos<0: 0f,1: 0f,2: 0f>
                mov r0.x, r0.x  // u<0:NaN:Inf>
                mov r0.y, r0.y  // v<0:NaN:Inf>
                nop 
                mov r0.x, r0.x  // u<0:NaN:Inf>
                mov r0.z, cb0[5].w  // n<0>
                
                #line 143
                iadd r0.z, r0.z, l(-2)
                itof r0.z, r0.z
                mul r0.w, r0.x, r0.z
                mul r0.w, r0.w, l(0.999900)
                round_ni r0.w, r0.w
                ftoi r0.w, r0.w
                iadd r0.w, l(2), r0.w  // GetKey<0>
                
                #line 270
                mov r0.w, r0.w  // iU<0>
                nop 
                mov r0.y, r0.y  // u<0:NaN:Inf>
                mov r2.x, cb0[6].x  // n<0>
                
                #line 143
                iadd r2.x, r2.x, l(-2)
                itof r2.x, r2.x
                mul r2.y, r0.y, r2.x
                mul r2.y, r2.y, l(0.999900)
                round_ni r2.y, r2.y
                ftoi r2.y, r2.y
                iadd r2.y, l(2), r2.y  // GetKey<0>
                
                #line 271
                mov r2.y, r2.y  // iV<0>
                
                #line 279
                mov x1[r2.y + 0].x, l(1.000000)  // basisV[r2.y/3]<0:Inf>
                mov x0[r0.w + 0].x, l(1.000000)  // basisU[r0.w/3]<0:Inf>
                
                #line 291
                nop 
                
                #line 135
                iadd r2.z, r0.w, l(-2)
                itof r2.z, r2.z
                div r2.z, r2.z, r0.z
                max r2.z, r2.z, l(0.000000)
                min r2.z, r2.z, l(1.000000)  // GetKnot<0:[0f,1f]>
                
                #line 291
                mov r2.z, r2.z  // gKI<0:[0f,1f]>
                nop 
                iadd r2.w, r0.w, l(1)  // i<0>
                
                #line 135
                iadd r2.w, r2.w, l(-2)
                itof r2.w, r2.w
                div r2.w, r2.w, r0.z
                max r2.w, r2.w, l(0.000000)
                min r2.w, r2.w, l(1.000000)  // GetKnot<0:[0f,1f]>
                
                #line 292
                mov r2.w, r2.w  // gKI1<0:[0f,1f]>
                nop 
                nop 
                iadd r3.x, r0.w, l(-1)
                iadd r3.y, r3.x, l(1)  // i<0>
                
                #line 135
                iadd r3.y, r3.y, l(-2)
                itof r3.y, r3.y
                div r3.y, r3.y, r0.z
                max r3.y, r3.y, l(0.000000)
                min r3.y, r3.y, l(1.000000)  // GetKnot<0:[0f,1f]>
                
                #line 294
                mov r3.y, r3.y  // gKIJ1<0:[0f,1f]>
                mov r2.z, -r2.z
                add r3.z, r0.x, r2.z
                add r3.w, r2.z, r2.w
                div r3.w, r3.z, r3.w  // c0U<0:NaN:Inf>
                mov r4.x, -r0.x
                add r4.y, r2.w, r4.x
                mov r3.y, -r3.y
                add r3.y, r2.w, r3.y
                div r3.y, r4.y, r3.y  // c1U<0:NaN:Inf>
                mul r3.w, r3.w, l(1.000000)
                mov x0[r0.w + 12].x, r3.w  // basisU[r0.w/3]<12:Inf>
                mul r3.y, r3.y, l(1.000000)
                mov x0[r3.x + 12].x, r3.y  // basisU[r3.x/3]<12:Inf>
                
                #line 301
                nop 
                
                #line 135
                iadd r3.x, r2.y, l(-2)
                itof r3.x, r3.x
                div r3.x, r3.x, r2.x
                max r3.x, r3.x, l(0.000000)
                min r3.x, r3.x, l(1.000000)  // GetKnot<0:[0f,1f]>
                
                #line 301
                mov r3.x, r3.x  // gKI<0:[0f,1f]>
                nop 
                iadd r4.z, r2.y, l(1)  // i<0>
                
                #line 135
                iadd r4.z, r4.z, l(-2)
                itof r4.z, r4.z
                div r4.z, r4.z, r2.x
                max r4.z, r4.z, l(0.000000)
                min r4.z, r4.z, l(1.000000)  // GetKnot<0:[0f,1f]>
                
                #line 302
                mov r4.z, r4.z  // gKI1<0:[0f,1f]>
                nop 
                nop 
                iadd r4.w, r2.y, l(-1)
                iadd r5.x, r4.w, l(1)  // i<0>
                
                #line 135
                iadd r5.x, r5.x, l(-2)
                itof r5.x, r5.x
                div r5.x, r5.x, r2.x
                max r5.x, r5.x, l(0.000000)
                min r5.x, r5.x, l(1.000000)  // GetKnot<0:[0f,1f]>
                
                #line 304
                mov r5.x, r5.x  // gKIJ1<0:[0f,1f]>
                mov r3.x, -r3.x
                add r5.y, r0.y, r3.x
                add r5.z, r3.x, r4.z
                div r5.z, r5.y, r5.z  // c0V<0:NaN:Inf>
                mov r5.w, -r0.y
                add r6.x, r4.z, r5.w
                mov r5.x, -r5.x
                add r5.x, r4.z, r5.x
                div r5.x, r6.x, r5.x  // c1V<0:NaN:Inf>
                mul r5.z, r5.z, l(1.000000)
                mov x1[r2.y + 12].x, r5.z  // basisV[r2.y/3]<12:Inf>
                mul r5.x, r5.x, l(1.000000)
                mov x1[r4.w + 12].x, r5.x  // basisV[r4.w/3]<12:Inf>
                
                #line 291
                nop 
                nop 
                nop 
                iadd r4.w, r0.w, l(2)  // i<0>
                
                #line 135
                iadd r4.w, r4.w, l(-2)
                itof r4.w, r4.w
                div r4.w, r4.w, r0.z
                max r4.w, r4.w, l(0.000000)
                min r4.w, r4.w, l(1.000000)  // GetKnot<0:[0f,1f]>
                
                #line 293
                mov r4.w, r4.w  // gKIJ<0:[0f,1f]>
                nop 
                iadd r6.y, r0.w, l(-2)
                iadd r6.z, r6.y, l(1)  // i<0>
                
                #line 135
                iadd r6.w, r6.z, l(-2)
                itof r6.w, r6.w
                div r6.w, r6.w, r0.z
                max r6.w, r6.w, l(0.000000)
                min r6.w, r6.w, l(1.000000)  // GetKnot<0:[0f,1f]>
                
                #line 294
                mov r6.w, r6.w  // gKIJ1<0:[0f,1f]>
                add r2.z, r2.z, r4.w
                div r2.z, r3.z, r2.z  // c0U<0:NaN:Inf>
                mov r3.z, -r6.w
                add r2.w, r2.w, r3.z
                div r2.w, r4.y, r2.w  // c1U<0:NaN:Inf>
                mul r2.z, r3.w, r2.z
                mov x0[r0.w + 24].x, r2.z  // basisU[r0.w/3]<24:Inf>
                mul r2.z, r3.y, r2.w
                mov x0[r6.y + 24].x, r2.z  // basisU[r6.y/3]<24:Inf>
                
                #line 301
                nop 
                nop 
                nop 
                iadd r2.w, r2.y, l(2)  // i<0>
                
                #line 135
                iadd r2.w, r2.w, l(-2)
                itof r2.w, r2.w
                div r2.w, r2.w, r2.x
                max r2.w, r2.w, l(0.000000)
                min r2.w, r2.w, l(1.000000)  // GetKnot<0:[0f,1f]>
                
                #line 303
                mov r2.w, r2.w  // gKIJ<0:[0f,1f]>
                nop 
                iadd r3.z, r2.y, l(-2)
                iadd r4.y, r3.z, l(1)  // i<0>
                
                #line 135
                iadd r4.w, r4.y, l(-2)
                itof r4.w, r4.w
                div r4.w, r4.w, r2.x
                max r4.w, r4.w, l(0.000000)
                min r4.w, r4.w, l(1.000000)  // GetKnot<0:[0f,1f]>
                
                #line 304
                mov r4.w, r4.w  // gKIJ1<0:[0f,1f]>
                add r2.w, r3.x, r2.w
                div r2.w, r5.y, r2.w  // c0V<0:NaN:Inf>
                mov r3.x, -r4.w
                add r3.x, r3.x, r4.z
                div r3.x, r6.x, r3.x  // c1V<0:NaN:Inf>
                mul r2.w, r5.z, r2.w
                mov x1[r2.y + 24].x, r2.w  // basisV[r2.y/3]<24:Inf>
                mul r2.w, r5.x, r3.x
                mov x1[r3.z + 24].x, r2.w  // basisV[r3.z/3]<24:Inf>
                
                #line 317
                ilt r3.x, r6.z, r0.w
                if_nz r3.x
                  mov r3.x, r6.z  // k<0>
                  nop 
                  mov r3.x, r3.x  // i<0>
                
                #line 135
                  iadd r4.z, r3.x, l(-2)
                  itof r4.z, r4.z
                  div r4.z, r4.z, r0.z
                  max r4.z, r4.z, l(0.000000)
                  min r4.z, r4.z, l(1.000000)  // GetKnot<0:[0f,1f]>
                
                #line 319
                  mov r4.z, r4.z  // gKK<0:[0f,1f]>
                  nop 
                  iadd r4.w, r3.x, l(1)  // i<0>
                
                #line 135
                  iadd r4.w, r4.w, l(-2)
                  itof r4.w, r4.w
                  div r4.w, r4.w, r0.z
                  max r4.w, r4.w, l(0.000000)
                  min r4.w, r4.w, l(1.000000)  // GetKnot<0:[0f,1f]>
                
                #line 320
                  mov r4.w, r4.w  // gKK1<0:[0f,1f]>
                  nop 
                  iadd r5.y, r3.x, l(2)  // i<0>
                
                #line 135
                  iadd r6.x, r5.y, l(-2)
                  itof r6.x, r6.x
                  div r6.x, r6.x, r0.z
                  max r6.x, r6.x, l(0.000000)
                  min r6.x, r6.x, l(1.000000)  // GetKnot<0:[0f,1f]>
                
                #line 321
                  mov r6.x, r6.x  // gKKJ<0:[0f,1f]>
                  nop 
                  iadd r5.y, r5.y, l(1)  // i<0>
                
                #line 135
                  iadd r5.y, r5.y, l(-2)
                  itof r5.y, r5.y
                  div r0.z, r5.y, r0.z
                  max r0.z, r0.z, l(0.000000)
                  min r0.z, r0.z, l(1.000000)  // GetKnot<0:[0f,1f]>
                
                #line 322
                  mov r0.z, r0.z  // gKKJ1<0:[0f,1f]>
                  mov r4.z, -r4.z
                  add r0.x, r0.x, r4.z
                  add r4.z, r4.z, r6.x
                  div r0.x, r0.x, r4.z  // c0U<0:NaN:Inf>
                  add r4.x, r4.x, r0.z
                  mov r4.z, -r4.w
                  add r0.z, r0.z, r4.z
                  div r0.z, r4.x, r0.z  // c1U<0:NaN:Inf>
                  mul r0.x, r3.y, r0.x
                  mul r0.z, r3.w, r0.z
                  add r0.x, r0.z, r0.x
                  mov x0[r3.x + 24].x, r0.x  // basisU[r3.x/3]<24:Inf>
                
                #line 317
                endif 
                
                #line 330
                ilt r0.x, r4.y, r2.y
                if_nz r0.x
                  mov r0.x, r4.y  // k<0>
                  nop 
                  mov r0.x, r0.x  // i<0>
                
                #line 135
                  iadd r0.z, r0.x, l(-2)
                  itof r0.z, r0.z
                  div r0.z, r0.z, r2.x
                  max r0.z, r0.z, l(0.000000)
                  min r0.z, r0.z, l(1.000000)  // GetKnot<0:[0f,1f]>
                
                #line 332
                  mov r0.z, r0.z  // gKK<0:[0f,1f]>
                  nop 
                  iadd r3.x, r0.x, l(1)  // i<0>
                
                #line 135
                  iadd r3.x, r3.x, l(-2)
                  itof r3.x, r3.x
                  div r3.x, r3.x, r2.x
                  max r3.x, r3.x, l(0.000000)
                  min r3.x, r3.x, l(1.000000)  // GetKnot<0:[0f,1f]>
                
                #line 333
                  mov r3.x, r3.x  // gKK1<0:[0f,1f]>
                  nop 
                  iadd r3.y, r0.x, l(2)  // i<0>
                
                #line 135
                  iadd r3.w, r3.y, l(-2)
                  itof r3.w, r3.w
                  div r3.w, r3.w, r2.x
                  max r3.w, r3.w, l(0.000000)
                  min r3.w, r3.w, l(1.000000)  // GetKnot<0:[0f,1f]>
                
                #line 334
                  mov r3.w, r3.w  // gKKJ<0:[0f,1f]>
                  nop 
                  iadd r3.y, r3.y, l(1)  // i<0>
                
                #line 135
                  iadd r3.y, r3.y, l(-2)
                  itof r3.y, r3.y
                  div r2.x, r3.y, r2.x
                  max r2.x, r2.x, l(0.000000)
                  min r2.x, r2.x, l(1.000000)  // GetKnot<0:[0f,1f]>
                
                #line 335
                  mov r2.x, r2.x  // gKKJ1<0:[0f,1f]>
                  mov r0.z, -r0.z
                  add r0.y, r0.z, r0.y
                  add r0.z, r0.z, r3.w
                  div r0.y, r0.y, r0.z  // c0V<0:NaN:Inf>
                  add r0.z, r5.w, r2.x
                  mov r3.x, -r3.x
                  add r2.x, r2.x, r3.x
                  div r0.z, r0.z, r2.x  // c1V<0:NaN:Inf>
                  mul r0.y, r5.x, r0.y
                  mul r0.z, r5.z, r0.z
                  add r0.y, r0.z, r0.y
                  mov x1[r0.x + 24].x, r0.y  // basisV[r0.x/3]<24:Inf>
                
                #line 330
                endif 
                
                #line 343
                ige r0.x, r0.w, r6.y
                not r0.y, r0.x
                if_nz r0.x
                
                #line 346
                  iadd r1.w, r2.y, l(-2)  // jV<0>
                  ige r0.x, r2.y, r1.w
                  not r0.z, r0.x
                  if_nz r0.x
                    mul r0.x, r2.w, r2.z
                    imad r2.x, r1.w, cb0[5].w, r6.y
                    mul r3.xyw, r0.xxxx, cb0[r2.x + 7].xyxz
                    add r5.xyz, r3.xywx, l(0.000000, 0.000000, 0.000000, 0.000000)  // pos<0:NaN:Inf,1:NaN:Inf,2:NaN:Inf>
                    iadd r5.w, r1.w, l(1)  // jV<0>
                  else 
                    mov r5.xyzw, r1.xyzw  // pos<0: 0f,1: 0f,2: 0f>, jV<0>
                  endif 
                  iadd r0.x, r1.w, l(1)  // jV<0>
                  not r0.z, r0.z
                  ige r1.x, r2.y, r0.x
                  and r0.z, r0.z, r1.x
                  mov r1.x, r5.w  // jV<0>
                  not r1.y, r0.z
                  if_nz r0.z
                    mov r0.z, r1.x
                    mov r0.z, x1[r0.z + 24].x  // basisV<24:NaN:Inf>
                    mul r0.z, r0.z, r2.z
                    imad r1.z, r1.x, cb0[5].w, r6.y
                    mul r3.xyw, r0.zzzz, cb0[r1.z + 7].xyxz
                    add r5.xyz, r3.xywx, r5.xyzx  // pos<0:NaN:Inf,1:NaN:Inf,2:NaN:Inf>
                    iadd r5.w, r1.x, l(1)  // jV<0>
                  endif 
                  iadd r0.x, r0.x, l(1)  // jV<0>
                  not r0.z, r1.y
                  ige r0.x, r2.y, r0.x
                  and r0.x, r0.z, r0.x
                  if_nz r0.x
                    mov r0.x, r5.w
                    mov r0.x, x1[r0.x + 24].x  // basisV<24:NaN:Inf>
                    mul r0.x, r0.x, r2.z
                    imad r0.z, r5.w, cb0[5].w, r6.y
                    mul r1.xyz, r0.xxxx, cb0[r0.z + 7].xyzx
                    add r5.xyz, r1.xyzx, r5.xyzx  // pos<0:NaN:Inf,1:NaN:Inf,2:NaN:Inf>
                  endif 
                  mov r6.y, r6.z  // jU<0>
                
                #line 343
                else 
                  mov r5.xyz, l(0,0,0,0)  // pos<0: 0f,1: 0f,2: 0f>
                  mov r6.y, r6.y  // jU<0>
                endif 
                not r0.x, r0.y
                ige r0.y, r0.w, r6.z
                and r0.x, r0.x, r0.y
                not r0.y, r0.x
                if_nz r0.x
                
                #line 346
                  ige r0.x, r2.y, r3.z
                  not r0.z, r0.x
                  if_nz r0.x
                    mov r0.x, r6.y
                    mov r0.x, x0[r0.x + 24].x  // basisU<24:NaN:Inf>
                    mul r0.x, r2.w, r0.x
                    imad r1.x, r3.z, cb0[5].w, r6.y
                    mul r1.xyz, r0.xxxx, cb0[r1.x + 7].xyzx
                    add r5.xyz, r1.xyzx, r5.xyzx  // pos<0:NaN:Inf,1:NaN:Inf,2:NaN:Inf>
                    mov r0.x, r4.y  // jV<0>
                  else 
                    mov r0.x, r3.z  // jV<0>
                  endif 
                  not r0.z, r0.z
                  ige r1.x, r2.y, r4.y
                  and r0.z, r0.z, r1.x
                  not r1.x, r0.z
                  if_nz r0.z
                    mov r0.z, r6.y
                    mov r0.z, x0[r0.z + 24].x  // basisU<24:NaN:Inf>
                    mov r1.y, r0.x
                    mov r1.y, x1[r1.y + 24].x  // basisV<24:NaN:Inf>
                    mul r0.z, r0.z, r1.y
                    imad r1.y, r0.x, cb0[5].w, r6.y
                    mul r1.yzw, r0.zzzz, cb0[r1.y + 7].xxyz
                    add r5.xyz, r1.yzwy, r5.xyzx  // pos<0:NaN:Inf,1:NaN:Inf,2:NaN:Inf>
                    iadd r0.x, r0.x, l(1)  // jV<0>
                  endif 
                  iadd r0.z, r4.y, l(1)  // jV<0>
                  not r1.x, r1.x
                  ige r0.z, r2.y, r0.z
                  and r0.z, r1.x, r0.z
                  if_nz r0.z
                    mov r0.z, r6.y
                    mov r0.z, x0[r0.z + 24].x  // basisU<24:NaN:Inf>
                    mov r1.x, r0.x
                    mov r1.x, x1[r1.x + 24].x  // basisV<24:NaN:Inf>
                    mul r0.z, r0.z, r1.x
                    imad r0.x, r0.x, cb0[5].w, r6.y
                    mul r1.xyz, r0.zzzz, cb0[r0.x + 7].xyzx
                    add r5.xyz, r1.xyzx, r5.xyzx  // pos<0:NaN:Inf,1:NaN:Inf,2:NaN:Inf>
                  endif 
                
                #line 343
                  iadd r6.y, r6.y, l(1)  // jU<0>
                endif 
                iadd r0.x, r6.z, l(1)  // jU<0>
                not r0.y, r0.y
                ige r0.x, r0.w, r0.x
                and r0.x, r0.y, r0.x
                if_nz r0.x
                
                #line 346
                  ige r0.x, r2.y, r3.z
                  not r0.y, r0.x
                  if_nz r0.x
                    mov r0.x, r6.y
                    mov r0.x, x0[r0.x + 24].x  // basisU<24:NaN:Inf>
                    mul r0.x, r2.w, r0.x
                    imad r0.z, r3.z, cb0[5].w, r6.y
                    mul r0.xzw, r0.xxxx, cb0[r0.z + 7].xxyz
                    add r5.xyz, r0.xzwx, r5.xyzx  // pos<0:NaN:Inf,1:NaN:Inf,2:NaN:Inf>
                    mov r3.z, r4.y  // jV<0>
                  else 
                    mov r3.z, r3.z  // jV<0>
                  endif 
                  not r0.x, r0.y
                  ige r0.y, r2.y, r4.y
                  and r0.x, r0.x, r0.y
                  not r0.y, r0.x
                  if_nz r0.x
                    mov r0.x, r6.y
                    mov r0.x, x0[r0.x + 24].x  // basisU<24:NaN:Inf>
                    mov r0.z, r3.z
                    mov r0.z, x1[r0.z + 24].x  // basisV<24:NaN:Inf>
                    mul r0.x, r0.z, r0.x
                    imad r0.z, r3.z, cb0[5].w, r6.y
                    mul r0.xzw, r0.xxxx, cb0[r0.z + 7].xxyz
                    add r5.xyz, r0.xzwx, r5.xyzx  // pos<0:NaN:Inf,1:NaN:Inf,2:NaN:Inf>
                    iadd r3.z, r3.z, l(1)  // jV<0>
                  endif 
                  iadd r0.x, r4.y, l(1)  // jV<0>
                  not r0.y, r0.y
                  ige r0.x, r2.y, r0.x
                  and r0.x, r0.y, r0.x
                  if_nz r0.x
                    mov r0.x, r6.y
                    mov r0.x, x0[r0.x + 24].x  // basisU<24:NaN:Inf>
                    mov r0.y, r3.z
                    mov r0.y, x1[r0.y + 24].x  // basisV<24:NaN:Inf>
                    mul r0.x, r0.y, r0.x
                    imad r0.y, r3.z, cb0[5].w, r6.y
                    mul r0.xyz, r0.xxxx, cb0[r0.y + 7].xyzx
                    add r5.xyz, r0.xyzx, r5.xyzx  // pos<0:NaN:Inf,1:NaN:Inf,2:NaN:Inf>
                  endif 
                
                #line 343
                endif 
                
                #line 21 "CPSurfaces-NormalDepthTech.fx"
                mov r5.xyz, r5.xyzx  // dout<0:NaN:Inf,1:NaN:Inf,2:NaN:Inf>
                mov o0.xyz, r5.xyzx  // DS_DepthOnly<0:NaN:Inf,1:NaN:Inf,2:NaN:Inf>
                ret 
                // Approximately 409 instruction slots used
                            
            };
            GeometryShader = asm {
                //
                // Generated by Microsoft (R) HLSL Shader Compiler 9.29.952.3111
                //
                //
                // Buffer Definitions: 
                //
                // cbuffer cbPerObject
                // {
                //
                //   float4x4 gViewProj;                // Offset:    0 Size:    64
                //   float3 gEyePosW;                   // Offset:   64 Size:    12 [unused]
                //   float gMaxTessDistance;            // Offset:   76 Size:     4 [unused]
                //   float gMinTessDistance;            // Offset:   80 Size:     4 [unused]
                //   float gMinTessFactor;              // Offset:   84 Size:     4 [unused]
                //   float gMaxTessFactor;              // Offset:   88 Size:     4 [unused]
                //   int gNU;                           // Offset:   92 Size:     4 [unused]
                //   int gNV;                           // Offset:   96 Size:     4 [unused]
                //   float4 gCP[100];                   // Offset:  112 Size:  1600 [unused]
                //   float3 gCenter;                    // Offset: 1712 Size:    12 [unused]
                //
                // }
                //
                //
                // Resource Bindings:
                //
                // Name                                 Type  Format         Dim Slot Elements
                // ------------------------------ ---------- ------- ----------- ---- --------
                // cbPerObject                       cbuffer      NA          NA    0        1
                //
                //
                //
                // Input signature:
                //
                // Name                 Index   Mask Register SysValue Format   Used
                // -------------------- ----- ------ -------- -------- ------ ------
                // POSTION                  0   xyz         0     NONE  float   xyz 
                //
                //
                // Output signature:
                //
                // Name                 Index   Mask Register SysValue Format   Used
                // -------------------- ----- ------ -------- -------- ------ ------
                // m0:SV_POSITION           0   xyzw        0      POS  float   xyzw
                //
                gs_5_0
                dcl_globalFlags refactoringAllowed
                dcl_constantbuffer cb0[4], immediateIndexed
                dcl_input v[3][0].xyz
                dcl_temps 4
                dcl_inputprimitive triangle 
                dcl_stream m0
                dcl_outputtopology trianglestrip 
                dcl_output_siv o0.xyzw, position
                dcl_maxout 3
                
                #line 50 "CPSurfaces-NormalDepthTech.fx"
                mov r0.xyz, v[0][0].xyzx
                mov r0.w, l(1.000000)
                dp4 r1.x, r0.xyzw, cb0[0].xyzw
                dp4 r1.y, r0.xyzw, cb0[1].xyzw
                dp4 r1.z, r0.xyzw, cb0[2].xyzw
                dp4 r0.x, r0.xyzw, cb0[3].xyzw
                mov r2.xyz, v[1][0].xyzx
                mov r2.w, l(1.000000)
                dp4 r0.y, r2.xyzw, cb0[0].xyzw
                dp4 r0.z, r2.xyzw, cb0[1].xyzw
                dp4 r0.w, r2.xyzw, cb0[2].xyzw
                dp4 r1.w, r2.xyzw, cb0[3].xyzw
                mov r2.xyz, v[2][0].xyzx
                mov r2.w, l(1.000000)
                dp4 r3.x, r2.xyzw, cb0[0].xyzw
                dp4 r3.y, r2.xyzw, cb0[1].xyzw
                dp4 r3.z, r2.xyzw, cb0[2].xyzw
                dp4 r2.x, r2.xyzw, cb0[3].xyzw
                
                #line 53
                mov o0.x, r1.x  // triStream<0>
                mov o0.y, r1.y  // triStream<0>
                mov o0.z, r1.z  // triStream<0>
                mov o0.w, r0.x  // triStream<0>
                emit_stream m0
                mov o0.x, r0.y  // triStream<0>
                mov o0.y, r0.z  // triStream<0>
                mov o0.z, r0.w  // triStream<0>
                mov o0.w, r1.w  // triStream<0>
                emit_stream m0
                mov o0.x, r3.x  // triStream<0>
                mov o0.y, r3.y  // triStream<0>
                mov o0.z, r3.z  // triStream<0>
                mov o0.w, r2.x  // triStream<0>
                emit_stream m0
                
                #line 43
                ret 
                // Approximately 34 instruction slots used
                            
            };
            PixelShader = NULL;
            RasterizerState = Depth;
        }

    }

    technique11 BSplineDraw_DepthOnlyAlphaClip
    {
        pass P0
        {
            VertexShader = asm {
                //
                // Generated by Microsoft (R) HLSL Shader Compiler 9.29.952.3111
                //
                //
                //
                // Input signature:
                //
                // Name                 Index   Mask Register SysValue Format   Used
                // -------------------- ----- ------ -------- -------- ------ ------
                // TEXCOORD                 0   xy          0     NONE  float   xy  
                //
                //
                // Output signature:
                //
                // Name                 Index   Mask Register SysValue Format   Used
                // -------------------- ----- ------ -------- -------- ------ ------
                // TEXCOORD                 0   xy          0     NONE  float   xy  
                //
                vs_5_0
                dcl_globalFlags refactoringAllowed
                dcl_input v0.xy
                dcl_output o0.xy
                dcl_temps 1
                
                #line 11 "CPSurfaces-FinalComplete.fx"
                mov r0.xy, v0.xyxx  // vout<0,1>
                mov o0.xy, r0.xyxx  // VS<0,1>
                ret 
                // Approximately 3 instruction slots used
                            
            };
            HullShader = asm {
                //
                // Generated by Microsoft (R) HLSL Shader Compiler 9.29.952.3111
                //
                //
                // Buffer Definitions: 
                //
                // cbuffer cbPerObject
                // {
                //
                //   float4x4 gViewProj;                // Offset:    0 Size:    64 [unused]
                //   float3 gEyePosW;                   // Offset:   64 Size:    12
                //   float gMaxTessDistance;            // Offset:   76 Size:     4
                //   float gMinTessDistance;            // Offset:   80 Size:     4
                //   float gMinTessFactor;              // Offset:   84 Size:     4
                //   float gMaxTessFactor;              // Offset:   88 Size:     4
                //   int gNU;                           // Offset:   92 Size:     4 [unused]
                //   int gNV;                           // Offset:   96 Size:     4 [unused]
                //   float4 gCP[100];                   // Offset:  112 Size:  1600 [unused]
                //   float3 gCenter;                    // Offset: 1712 Size:    12
                //
                // }
                //
                //
                // Resource Bindings:
                //
                // Name                                 Type  Format         Dim Slot Elements
                // ------------------------------ ---------- ------- ----------- ---- --------
                // cbPerObject                       cbuffer      NA          NA    0        1
                //
                //
                //
                // Patch Constant signature:
                //
                // Name                 Index   Mask Register SysValue Format   Used
                // -------------------- ----- ------ -------- -------- ------ ------
                // SV_TessFactor            0   x           0  TRIEDGE  float   x   
                // SV_TessFactor            1   x           1  TRIEDGE  float   x   
                // SV_TessFactor            2   x           2  TRIEDGE  float   x   
                // SV_InsideTessFactor      0   x           3   TRIINT  float   x   
                //
                //
                // Input signature:
                //
                // Name                 Index   Mask Register SysValue Format   Used
                // -------------------- ----- ------ -------- -------- ------ ------
                // TEXCOORD                 0   xy          0     NONE  float   xy  
                //
                //
                // Output signature:
                //
                // Name                 Index   Mask Register SysValue Format   Used
                // -------------------- ----- ------ -------- -------- ------ ------
                // TEXCOORD                 0   xy          0     NONE  float   xy  
                //
                // Tessellation Domain   # of control points
                // -------------------- --------------------
                // Triangle                                3
                //
                // Tessellation Output Primitive  Partitioning Type 
                // ------------------------------ ------------------
                // Clockwise Triangles            Integer           
                //
                hs_5_0
                hs_decls 
                dcl_input_control_point_count 3
                dcl_output_control_point_count 3
                dcl_tessellator_domain domain_tri
                dcl_tessellator_partitioning partitioning_integer
                dcl_tessellator_output_primitive output_triangle_cw
                dcl_hs_max_tessfactor l(64.000000)
                dcl_globalFlags refactoringAllowed
                dcl_constantbuffer cb0[108], immediateIndexed
                
                #line 44 "CPSurfaces-FinalComplete.fx"
                hs_control_point_phase 
                dcl_input vOutputControlPointID
                dcl_input v[3][0].xy
                dcl_output o0.xy
                dcl_temps 1
                mov r0.x, vOutputControlPointID  // hout<0,1>
                mov r0.xy, v[r0.x + 0][0].xyxx  // HS<0,1>
                mov o0.xy, r0.xyxx
                
                #line 26
                ret 
                hs_join_phase   // p<0,1,2>
                dcl_output_siv o0.x, finalTriUeq0EdgeTessFactor
                dcl_output_siv o1.x, finalTriVeq0EdgeTessFactor
                dcl_output_siv o2.x, finalTriWeq0EdgeTessFactor
                dcl_output_siv o3.x, finalTriInsideTessFactor
                dcl_temps 2
                
                #line 85 "CPSurfaces-Utilities.fx"
                nop 
                mov r0.xyz, cb0[107].xyzx
                mov r1.xyz, -cb0[4].xyzx
                add r0.xyz, r0.xyzx, r1.xyzx  // d<0:NaN:Inf>
                dp3 r0.x, r0.xyzx, r0.xyzx
                sqrt r0.x, r0.x
                mov r0.y, -cb0[5].x
                add r0.x, r0.y, r0.x
                add r0.y, r0.y, cb0[4].w
                div r0.x, r0.x, r0.y  // s<0:[0f,1f]>
                max r0.x, r0.x, l(0.000000)
                min r0.x, r0.x, l(1.000000)
                log r0.x, r0.x
                mul r0.x, r0.x, l(1.500000)
                exp r0.x, r0.x
                mov r0.y, -cb0[5].y
                add r0.y, r0.y, cb0[5].z  // CalcTessFactor<0:NaN:Inf>
                
                #line 26 "CPSurfaces-FinalComplete.fx"
                mul r0.x, r0.y, r0.x  // tess<0:NaN:Inf>
                add r0.w, r0.x, cb0[5].y  // pt<0:NaN:Inf>
                
                #line 32
                mov r0.w, r0.w  // ConstantHS<0:NaN:Inf>
                mov r0.w, r0.w  // ConstantHS<1:NaN:Inf>
                mov r0.x, r0.w  // ConstantHS<2:NaN:Inf>
                mov r0.y, r0.w  // ConstantHS<3:NaN:Inf>
                mov r0.z, r0.w  // ConstantHS<0:Inf:[-1.#INFf,64f],1:Inf:[-1.#INFf,64f],2:Inf:[-1.#INFf,64f],3:Inf:[-1.#INFf,64f]>
                mov r0.w, r0.w  // ConstantHS<0:Inf:[-1.#INFf,64f]>
                min r0.xyzw, r0.xyzw, l(64.000000, 64.000000, 64.000000, 64.000000)  // ConstantHS<1:Inf:[-1.#INFf,64f]>
                mov o0.x, r0.x  // ConstantHS<2:Inf:[-1.#INFf,64f]>
                mov o1.x, r0.y  // ConstantHS<3:Inf:[-1.#INFf,64f]>
                mov o2.x, r0.z
                
                // incorrect instruction offset in debug info
                mov o3.x, r0.w
                // incorrect instruction offset in debug info
                
                
                // incorrect instruction offset in debug info
                ret 
                // incorrect instruction offset in debug info
                
                // Approximately 35 instruction slots used
                            
            };
            DomainShader = asm {
                //
                // Generated by Microsoft (R) HLSL Shader Compiler 9.29.952.3111
                //
                //
                // Buffer Definitions: 
                //
                // cbuffer cbPerObject
                // {
                //
                //   float4x4 gViewProj;                // Offset:    0 Size:    64 [unused]
                //   float3 gEyePosW;                   // Offset:   64 Size:    12 [unused]
                //   float gMaxTessDistance;            // Offset:   76 Size:     4 [unused]
                //   float gMinTessDistance;            // Offset:   80 Size:     4 [unused]
                //   float gMinTessFactor;              // Offset:   84 Size:     4 [unused]
                //   float gMaxTessFactor;              // Offset:   88 Size:     4 [unused]
                //   int gNU;                           // Offset:   92 Size:     4
                //   int gNV;                           // Offset:   96 Size:     4
                //   float4 gCP[100];                   // Offset:  112 Size:  1600
                //   float3 gCenter;                    // Offset: 1712 Size:    12 [unused]
                //
                // }
                //
                //
                // Resource Bindings:
                //
                // Name                                 Type  Format         Dim Slot Elements
                // ------------------------------ ---------- ------- ----------- ---- --------
                // cbPerObject                       cbuffer      NA          NA    0        1
                //
                //
                //
                // Patch Constant signature:
                //
                // Name                 Index   Mask Register SysValue Format   Used
                // -------------------- ----- ------ -------- -------- ------ ------
                // SV_TessFactor            0   x           0  TRIEDGE  float       
                // SV_TessFactor            1   x           1  TRIEDGE  float       
                // SV_TessFactor            2   x           2  TRIEDGE  float       
                // SV_InsideTessFactor      0   x           3   TRIINT  float       
                //
                //
                // Input signature:
                //
                // Name                 Index   Mask Register SysValue Format   Used
                // -------------------- ----- ------ -------- -------- ------ ------
                // TEXCOORD                 0   xy          0     NONE  float   xy  
                //
                //
                // Output signature:
                //
                // Name                 Index   Mask Register SysValue Format   Used
                // -------------------- ----- ------ -------- -------- ------ ------
                // POSTION                  0   xyz         0     NONE  float   xyz 
                // TEXCOORD                 0   xy          1     NONE  float   xy  
                //
                // Tessellation Domain   # of control points
                // -------------------- --------------------
                // Triangle                                3
                //
                ds_5_0
                dcl_input_control_point_count 3
                dcl_tessellator_domain domain_tri
                dcl_globalFlags refactoringAllowed
                dcl_constantbuffer cb0[107], dynamicIndexed
                dcl_input vDomain.xyz
                dcl_input vicp[3][0].xy
                dcl_output o0.xyz
                dcl_output o1.xy
                dcl_temps 8
                dcl_indexableTemp x0[36], 4
                dcl_indexableTemp x1[36], 4
                
                #line 32 "CPSurfaces-NormalDepthTech.fx"
                mul r0.xy, vDomain.xxxx, vicp[0][0].xyxx
                mul r0.zw, vDomain.yyyy, vicp[1][0].xxxy
                add r0.xy, r0.zwzz, r0.xyxx
                mul r0.zw, vDomain.zzzz, vicp[2][0].xxxy
                add r0.xy, r0.zwzz, r0.xyxx  // texCoord<0:NaN:Inf,1:NaN:Inf>
                
                #line 35
                nop 
                mov r0.xy, r0.xyxx  // texCoord<0:NaN:Inf,1:NaN:Inf>
                
                #line 266 "CPSurfaces-Utilities.fx"
                mov r1.xyz, l(0,0,0,0)  // pos<0: 0f,1: 0f,2: 0f>
                mov r0.z, r0.x  // u<0:NaN:Inf>
                mov r0.w, r0.y  // v<0:NaN:Inf>
                nop 
                mov r0.z, r0.z  // u<0:NaN:Inf>
                mov r2.x, cb0[5].w  // n<0>
                
                #line 143
                iadd r2.x, r2.x, l(-2)
                itof r2.x, r2.x
                mul r2.y, r0.z, r2.x
                mul r2.y, r2.y, l(0.999900)
                round_ni r2.y, r2.y
                ftoi r2.y, r2.y
                iadd r2.y, l(2), r2.y  // GetKey<0>
                
                #line 270
                mov r2.y, r2.y  // iU<0>
                nop 
                mov r0.w, r0.w  // u<0:NaN:Inf>
                mov r2.z, cb0[6].x  // n<0>
                
                #line 143
                iadd r2.z, r2.z, l(-2)
                itof r2.z, r2.z
                mul r2.w, r0.w, r2.z
                mul r2.w, r2.w, l(0.999900)
                round_ni r2.w, r2.w
                ftoi r2.w, r2.w
                iadd r2.w, l(2), r2.w  // GetKey<0>
                
                #line 271
                mov r2.w, r2.w  // iV<0>
                
                #line 279
                mov x1[r2.w + 0].x, l(1.000000)  // basisV[r2.w/3]<0:Inf>
                mov x0[r2.y + 0].x, l(1.000000)  // basisU[r2.y/3]<0:Inf>
                
                #line 291
                nop 
                
                #line 135
                iadd r3.x, r2.y, l(-2)
                itof r3.x, r3.x
                div r3.x, r3.x, r2.x
                max r3.x, r3.x, l(0.000000)
                min r3.x, r3.x, l(1.000000)  // GetKnot<0:[0f,1f]>
                
                #line 291
                mov r3.x, r3.x  // gKI<0:[0f,1f]>
                nop 
                iadd r3.y, r2.y, l(1)  // i<0>
                
                #line 135
                iadd r3.y, r3.y, l(-2)
                itof r3.y, r3.y
                div r3.y, r3.y, r2.x
                max r3.y, r3.y, l(0.000000)
                min r3.y, r3.y, l(1.000000)  // GetKnot<0:[0f,1f]>
                
                #line 292
                mov r3.y, r3.y  // gKI1<0:[0f,1f]>
                nop 
                nop 
                iadd r3.z, r2.y, l(-1)
                iadd r3.w, r3.z, l(1)  // i<0>
                
                #line 135
                iadd r3.w, r3.w, l(-2)
                itof r3.w, r3.w
                div r3.w, r3.w, r2.x
                max r3.w, r3.w, l(0.000000)
                min r3.w, r3.w, l(1.000000)  // GetKnot<0:[0f,1f]>
                
                #line 294
                mov r3.w, r3.w  // gKIJ1<0:[0f,1f]>
                mov r3.x, -r3.x
                add r4.x, r0.z, r3.x
                add r4.y, r3.x, r3.y
                div r4.y, r4.x, r4.y  // c0U<0:NaN:Inf>
                mov r4.z, -r0.z
                add r4.w, r3.y, r4.z
                mov r3.w, -r3.w
                add r3.w, r3.w, r3.y
                div r3.w, r4.w, r3.w  // c1U<0:NaN:Inf>
                mul r4.y, r4.y, l(1.000000)
                mov x0[r2.y + 12].x, r4.y  // basisU[r2.y/3]<12:Inf>
                mul r3.w, r3.w, l(1.000000)
                mov x0[r3.z + 12].x, r3.w  // basisU[r3.z/3]<12:Inf>
                
                #line 301
                nop 
                
                #line 135
                iadd r3.z, r2.w, l(-2)
                itof r3.z, r3.z
                div r3.z, r3.z, r2.z
                max r3.z, r3.z, l(0.000000)
                min r3.z, r3.z, l(1.000000)  // GetKnot<0:[0f,1f]>
                
                #line 301
                mov r3.z, r3.z  // gKI<0:[0f,1f]>
                nop 
                iadd r5.x, r2.w, l(1)  // i<0>
                
                #line 135
                iadd r5.x, r5.x, l(-2)
                itof r5.x, r5.x
                div r5.x, r5.x, r2.z
                max r5.x, r5.x, l(0.000000)
                min r5.x, r5.x, l(1.000000)  // GetKnot<0:[0f,1f]>
                
                #line 302
                mov r5.x, r5.x  // gKI1<0:[0f,1f]>
                nop 
                nop 
                iadd r5.y, r2.w, l(-1)
                iadd r5.z, r5.y, l(1)  // i<0>
                
                #line 135
                iadd r5.z, r5.z, l(-2)
                itof r5.z, r5.z
                div r5.z, r5.z, r2.z
                max r5.z, r5.z, l(0.000000)
                min r5.z, r5.z, l(1.000000)  // GetKnot<0:[0f,1f]>
                
                #line 304
                mov r5.z, r5.z  // gKIJ1<0:[0f,1f]>
                mov r3.z, -r3.z
                add r5.w, r0.w, r3.z
                add r6.x, r3.z, r5.x
                div r6.x, r5.w, r6.x  // c0V<0:NaN:Inf>
                mov r6.y, -r0.w
                add r6.z, r5.x, r6.y
                mov r5.z, -r5.z
                add r5.z, r5.z, r5.x
                div r5.z, r6.z, r5.z  // c1V<0:NaN:Inf>
                mul r6.x, r6.x, l(1.000000)
                mov x1[r2.w + 12].x, r6.x  // basisV[r2.w/3]<12:Inf>
                mul r5.z, r5.z, l(1.000000)
                mov x1[r5.y + 12].x, r5.z  // basisV[r5.y/3]<12:Inf>
                
                #line 291
                nop 
                nop 
                nop 
                iadd r5.y, r2.y, l(2)  // i<0>
                
                #line 135
                iadd r5.y, r5.y, l(-2)
                itof r5.y, r5.y
                div r5.y, r5.y, r2.x
                max r5.y, r5.y, l(0.000000)
                min r5.y, r5.y, l(1.000000)  // GetKnot<0:[0f,1f]>
                
                #line 293
                mov r5.y, r5.y  // gKIJ<0:[0f,1f]>
                nop 
                iadd r6.w, r2.y, l(-2)
                iadd r7.x, r6.w, l(1)  // i<0>
                
                #line 135
                iadd r7.y, r7.x, l(-2)
                itof r7.y, r7.y
                div r7.y, r7.y, r2.x
                max r7.y, r7.y, l(0.000000)
                min r7.y, r7.y, l(1.000000)  // GetKnot<0:[0f,1f]>
                
                #line 294
                mov r7.y, r7.y  // gKIJ1<0:[0f,1f]>
                add r3.x, r3.x, r5.y
                div r3.x, r4.x, r3.x  // c0U<0:NaN:Inf>
                mov r4.x, -r7.y
                add r3.y, r3.y, r4.x
                div r3.y, r4.w, r3.y  // c1U<0:NaN:Inf>
                mul r3.x, r4.y, r3.x
                mov x0[r2.y + 24].x, r3.x  // basisU[r2.y/3]<24:Inf>
                mul r3.x, r3.w, r3.y
                mov x0[r6.w + 24].x, r3.x  // basisU[r6.w/3]<24:Inf>
                
                #line 301
                nop 
                nop 
                nop 
                iadd r3.y, r2.w, l(2)  // i<0>
                
                #line 135
                iadd r3.y, r3.y, l(-2)
                itof r3.y, r3.y
                div r3.y, r3.y, r2.z
                max r3.y, r3.y, l(0.000000)
                min r3.y, r3.y, l(1.000000)  // GetKnot<0:[0f,1f]>
                
                #line 303
                mov r3.y, r3.y  // gKIJ<0:[0f,1f]>
                nop 
                iadd r4.x, r2.w, l(-2)
                iadd r4.w, r4.x, l(1)  // i<0>
                
                #line 135
                iadd r5.y, r4.w, l(-2)
                itof r5.y, r5.y
                div r5.y, r5.y, r2.z
                max r5.y, r5.y, l(0.000000)
                min r5.y, r5.y, l(1.000000)  // GetKnot<0:[0f,1f]>
                
                #line 304
                mov r5.y, r5.y  // gKIJ1<0:[0f,1f]>
                add r3.y, r3.z, r3.y
                div r3.y, r5.w, r3.y  // c0V<0:NaN:Inf>
                mov r3.z, -r5.y
                add r3.z, r3.z, r5.x
                div r3.z, r6.z, r3.z  // c1V<0:NaN:Inf>
                mul r3.y, r6.x, r3.y
                mov x1[r2.w + 24].x, r3.y  // basisV[r2.w/3]<24:Inf>
                mul r3.y, r5.z, r3.z
                mov x1[r4.x + 24].x, r3.y  // basisV[r4.x/3]<24:Inf>
                
                #line 317
                ilt r3.z, r7.x, r2.y
                if_nz r3.z
                  mov r3.z, r7.x  // k<0>
                  nop 
                  mov r3.z, r3.z  // i<0>
                
                #line 135
                  iadd r5.x, r3.z, l(-2)
                  itof r5.x, r5.x
                  div r5.x, r5.x, r2.x
                  max r5.x, r5.x, l(0.000000)
                  min r5.x, r5.x, l(1.000000)  // GetKnot<0:[0f,1f]>
                
                #line 319
                  mov r5.x, r5.x  // gKK<0:[0f,1f]>
                  nop 
                  iadd r5.y, r3.z, l(1)  // i<0>
                
                #line 135
                  iadd r5.y, r5.y, l(-2)
                  itof r5.y, r5.y
                  div r5.y, r5.y, r2.x
                  max r5.y, r5.y, l(0.000000)
                  min r5.y, r5.y, l(1.000000)  // GetKnot<0:[0f,1f]>
                
                #line 320
                  mov r5.y, r5.y  // gKK1<0:[0f,1f]>
                  nop 
                  iadd r5.w, r3.z, l(2)  // i<0>
                
                #line 135
                  iadd r6.z, r5.w, l(-2)
                  itof r6.z, r6.z
                  div r6.z, r6.z, r2.x
                  max r6.z, r6.z, l(0.000000)
                  min r6.z, r6.z, l(1.000000)  // GetKnot<0:[0f,1f]>
                
                #line 321
                  mov r6.z, r6.z  // gKKJ<0:[0f,1f]>
                  nop 
                  iadd r5.w, r5.w, l(1)  // i<0>
                
                #line 135
                  iadd r5.w, r5.w, l(-2)
                  itof r5.w, r5.w
                  div r2.x, r5.w, r2.x
                  max r2.x, r2.x, l(0.000000)
                  min r2.x, r2.x, l(1.000000)  // GetKnot<0:[0f,1f]>
                
                #line 322
                  mov r2.x, r2.x  // gKKJ1<0:[0f,1f]>
                  mov r5.x, -r5.x
                  add r0.z, r0.z, r5.x
                  add r5.x, r5.x, r6.z
                  div r0.z, r0.z, r5.x  // c0U<0:NaN:Inf>
                  add r4.z, r4.z, r2.x
                  mov r5.x, -r5.y
                  add r2.x, r2.x, r5.x
                  div r2.x, r4.z, r2.x  // c1U<0:NaN:Inf>
                  mul r0.z, r3.w, r0.z
                  mul r2.x, r4.y, r2.x
                  add r0.z, r0.z, r2.x
                  mov x0[r3.z + 24].x, r0.z  // basisU[r3.z/3]<24:Inf>
                
                #line 317
                endif 
                
                #line 330
                ilt r0.z, r4.w, r2.w
                if_nz r0.z
                  mov r0.z, r4.w  // k<0>
                  nop 
                  mov r0.z, r0.z  // i<0>
                
                #line 135
                  iadd r2.x, r0.z, l(-2)
                  itof r2.x, r2.x
                  div r2.x, r2.x, r2.z
                  max r2.x, r2.x, l(0.000000)
                  min r2.x, r2.x, l(1.000000)  // GetKnot<0:[0f,1f]>
                
                #line 332
                  mov r2.x, r2.x  // gKK<0:[0f,1f]>
                  nop 
                  iadd r3.z, r0.z, l(1)  // i<0>
                
                #line 135
                  iadd r3.z, r3.z, l(-2)
                  itof r3.z, r3.z
                  div r3.z, r3.z, r2.z
                  max r3.z, r3.z, l(0.000000)
                  min r3.z, r3.z, l(1.000000)  // GetKnot<0:[0f,1f]>
                
                #line 333
                  mov r3.z, r3.z  // gKK1<0:[0f,1f]>
                  nop 
                  iadd r3.w, r0.z, l(2)  // i<0>
                
                #line 135
                  iadd r4.y, r3.w, l(-2)
                  itof r4.y, r4.y
                  div r4.y, r4.y, r2.z
                  max r4.y, r4.y, l(0.000000)
                  min r4.y, r4.y, l(1.000000)  // GetKnot<0:[0f,1f]>
                
                #line 334
                  mov r4.y, r4.y  // gKKJ<0:[0f,1f]>
                  nop 
                  iadd r3.w, r3.w, l(1)  // i<0>
                
                #line 135
                  iadd r3.w, r3.w, l(-2)
                  itof r3.w, r3.w
                  div r2.z, r3.w, r2.z
                  max r2.z, r2.z, l(0.000000)
                  min r2.z, r2.z, l(1.000000)  // GetKnot<0:[0f,1f]>
                
                #line 335
                  mov r2.z, r2.z  // gKKJ1<0:[0f,1f]>
                  mov r2.x, -r2.x
                  add r0.w, r0.w, r2.x
                  add r2.x, r2.x, r4.y
                  div r0.w, r0.w, r2.x  // c0V<0:NaN:Inf>
                  add r2.x, r6.y, r2.z
                  mov r3.z, -r3.z
                  add r2.z, r2.z, r3.z
                  div r2.x, r2.x, r2.z  // c1V<0:NaN:Inf>
                  mul r0.w, r5.z, r0.w
                  mul r2.x, r6.x, r2.x
                  add r0.w, r0.w, r2.x
                  mov x1[r0.z + 24].x, r0.w  // basisV[r0.z/3]<24:Inf>
                
                #line 330
                endif 
                
                #line 343
                ige r0.z, r2.y, r6.w
                not r0.w, r0.z
                if_nz r0.z
                
                #line 346
                  iadd r1.w, r2.w, l(-2)  // jV<0>
                  ige r0.z, r2.w, r1.w
                  not r2.x, r0.z
                  if_nz r0.z
                    mul r0.z, r3.y, r3.x
                    imad r2.z, r1.w, cb0[5].w, r6.w
                    mul r5.xyz, r0.zzzz, cb0[r2.z + 7].xyzx
                    add r5.xyz, r5.xyzx, l(0.000000, 0.000000, 0.000000, 0.000000)  // pos<0:NaN:Inf,1:NaN:Inf,2:NaN:Inf>
                    iadd r5.w, r1.w, l(1)  // jV<0>
                  else 
                    mov r5.xyzw, r1.xyzw  // pos<0: 0f,1: 0f,2: 0f>, jV<0>
                  endif 
                  iadd r0.z, r1.w, l(1)  // jV<0>
                  not r1.x, r2.x
                  ige r1.y, r2.w, r0.z
                  and r1.x, r1.x, r1.y
                  mov r1.y, r5.w  // jV<0>
                  not r1.z, r1.x
                  if_nz r1.x
                    mov r1.x, r1.y
                    mov r1.x, x1[r1.x + 24].x  // basisV<24:NaN:Inf>
                    mul r1.x, r1.x, r3.x
                    imad r1.w, r1.y, cb0[5].w, r6.w
                    mul r6.xyz, r1.xxxx, cb0[r1.w + 7].xyzx
                    add r5.xyz, r5.xyzx, r6.xyzx  // pos<0:NaN:Inf,1:NaN:Inf,2:NaN:Inf>
                    iadd r5.w, r1.y, l(1)  // jV<0>
                  endif 
                  iadd r0.z, r0.z, l(1)  // jV<0>
                  not r1.x, r1.z
                  ige r0.z, r2.w, r0.z
                  and r0.z, r1.x, r0.z
                  if_nz r0.z
                    mov r0.z, r5.w
                    mov r0.z, x1[r0.z + 24].x  // basisV<24:NaN:Inf>
                    mul r0.z, r0.z, r3.x
                    imad r1.x, r5.w, cb0[5].w, r6.w
                    mul r1.xyz, r0.zzzz, cb0[r1.x + 7].xyzx
                    add r5.xyz, r1.xyzx, r5.xyzx  // pos<0:NaN:Inf,1:NaN:Inf,2:NaN:Inf>
                  endif 
                  mov r6.w, r7.x  // jU<0>
                
                #line 343
                else 
                  mov r5.xyz, l(0,0,0,0)  // pos<0: 0f,1: 0f,2: 0f>
                  mov r6.w, r6.w  // jU<0>
                endif 
                not r0.z, r0.w
                ige r0.w, r2.y, r7.x
                and r0.z, r0.z, r0.w
                not r0.w, r0.z
                if_nz r0.z
                
                #line 346
                  ige r0.z, r2.w, r4.x
                  not r1.x, r0.z
                  if_nz r0.z
                    mov r0.z, r6.w
                    mov r0.z, x0[r0.z + 24].x  // basisU<24:NaN:Inf>
                    mul r0.z, r3.y, r0.z
                    imad r1.y, r4.x, cb0[5].w, r6.w
                    mul r1.yzw, r0.zzzz, cb0[r1.y + 7].xxyz
                    add r5.xyz, r1.yzwy, r5.xyzx  // pos<0:NaN:Inf,1:NaN:Inf,2:NaN:Inf>
                    mov r0.z, r4.w  // jV<0>
                  else 
                    mov r0.z, r4.x  // jV<0>
                  endif 
                  not r1.x, r1.x
                  ige r1.y, r2.w, r4.w
                  and r1.x, r1.x, r1.y
                  not r1.y, r1.x
                  if_nz r1.x
                    mov r1.x, r6.w
                    mov r1.x, x0[r1.x + 24].x  // basisU<24:NaN:Inf>
                    mov r1.z, r0.z
                    mov r1.z, x1[r1.z + 24].x  // basisV<24:NaN:Inf>
                    mul r1.x, r1.z, r1.x
                    imad r1.z, r0.z, cb0[5].w, r6.w
                    mul r1.xzw, r1.xxxx, cb0[r1.z + 7].xxyz
                    add r5.xyz, r1.xzwx, r5.xyzx  // pos<0:NaN:Inf,1:NaN:Inf,2:NaN:Inf>
                    iadd r0.z, r0.z, l(1)  // jV<0>
                  endif 
                  iadd r1.x, r4.w, l(1)  // jV<0>
                  not r1.y, r1.y
                  ige r1.x, r2.w, r1.x
                  and r1.x, r1.y, r1.x
                  if_nz r1.x
                    mov r1.x, r6.w
                    mov r1.x, x0[r1.x + 24].x  // basisU<24:NaN:Inf>
                    mov r1.y, r0.z
                    mov r1.y, x1[r1.y + 24].x  // basisV<24:NaN:Inf>
                    mul r1.x, r1.y, r1.x
                    imad r0.z, r0.z, cb0[5].w, r6.w
                    mul r1.xyz, r1.xxxx, cb0[r0.z + 7].xyzx
                    add r5.xyz, r1.xyzx, r5.xyzx  // pos<0:NaN:Inf,1:NaN:Inf,2:NaN:Inf>
                  endif 
                
                #line 343
                  iadd r6.w, r6.w, l(1)  // jU<0>
                endif 
                iadd r0.z, r7.x, l(1)  // jU<0>
                not r0.w, r0.w
                ige r0.z, r2.y, r0.z
                and r0.z, r0.w, r0.z
                if_nz r0.z
                
                #line 346
                  ige r0.z, r2.w, r4.x
                  not r0.w, r0.z
                  if_nz r0.z
                    mov r0.z, r6.w
                    mov r0.z, x0[r0.z + 24].x  // basisU<24:NaN:Inf>
                    mul r0.z, r3.y, r0.z
                    imad r1.x, r4.x, cb0[5].w, r6.w
                    mul r1.xyz, r0.zzzz, cb0[r1.x + 7].xyzx
                    add r5.xyz, r1.xyzx, r5.xyzx  // pos<0:NaN:Inf,1:NaN:Inf,2:NaN:Inf>
                    mov r4.x, r4.w  // jV<0>
                  else 
                    mov r4.x, r4.x  // jV<0>
                  endif 
                  not r0.z, r0.w
                  ige r0.w, r2.w, r4.w
                  and r0.z, r0.z, r0.w
                  not r0.w, r0.z
                  if_nz r0.z
                    mov r0.z, r6.w
                    mov r0.z, x0[r0.z + 24].x  // basisU<24:NaN:Inf>
                    mov r1.x, r4.x
                    mov r1.x, x1[r1.x + 24].x  // basisV<24:NaN:Inf>
                    mul r0.z, r0.z, r1.x
                    imad r1.x, r4.x, cb0[5].w, r6.w
                    mul r1.xyz, r0.zzzz, cb0[r1.x + 7].xyzx
                    add r5.xyz, r1.xyzx, r5.xyzx  // pos<0:NaN:Inf,1:NaN:Inf,2:NaN:Inf>
                    iadd r4.x, r4.x, l(1)  // jV<0>
                  endif 
                  iadd r0.z, r4.w, l(1)  // jV<0>
                  not r0.w, r0.w
                  ige r0.z, r2.w, r0.z
                  and r0.z, r0.w, r0.z
                  if_nz r0.z
                    mov r0.z, r6.w
                    mov r0.z, x0[r0.z + 24].x  // basisU<24:NaN:Inf>
                    mov r0.w, r4.x
                    mov r0.w, x1[r0.w + 24].x  // basisV<24:NaN:Inf>
                    mul r0.z, r0.w, r0.z
                    imad r0.w, r4.x, cb0[5].w, r6.w
                    mul r1.xyz, r0.zzzz, cb0[r0.w + 7].xyzx
                    add r5.xyz, r1.xyzx, r5.xyzx  // pos<0:NaN:Inf,1:NaN:Inf,2:NaN:Inf>
                  endif 
                
                #line 343
                endif 
                
                #line 35 "CPSurfaces-NormalDepthTech.fx"
                mov r5.xyz, r5.xyzx  // dout<0:NaN:Inf,1:NaN:Inf,2:NaN:Inf>
                
                #line 38
                mov o0.xyz, r5.xyzx  // DS_DepthOnlyAlphaClip<0:NaN:Inf,1:NaN:Inf,2:NaN:Inf>
                mov o1.xy, r0.xyxx  // DS_DepthOnlyAlphaClip<3:NaN:Inf,4:NaN:Inf>
                ret 
                // Approximately 410 instruction slots used
                            
            };
            GeometryShader = asm {
                //
                // Generated by Microsoft (R) HLSL Shader Compiler 9.29.952.3111
                //
                //
                // Buffer Definitions: 
                //
                // cbuffer cbPerObject
                // {
                //
                //   float4x4 gViewProj;                // Offset:    0 Size:    64
                //   float3 gEyePosW;                   // Offset:   64 Size:    12 [unused]
                //   float gMaxTessDistance;            // Offset:   76 Size:     4 [unused]
                //   float gMinTessDistance;            // Offset:   80 Size:     4 [unused]
                //   float gMinTessFactor;              // Offset:   84 Size:     4 [unused]
                //   float gMaxTessFactor;              // Offset:   88 Size:     4 [unused]
                //   int gNU;                           // Offset:   92 Size:     4 [unused]
                //   int gNV;                           // Offset:   96 Size:     4 [unused]
                //   float4 gCP[100];                   // Offset:  112 Size:  1600 [unused]
                //   float3 gCenter;                    // Offset: 1712 Size:    12 [unused]
                //
                // }
                //
                //
                // Resource Bindings:
                //
                // Name                                 Type  Format         Dim Slot Elements
                // ------------------------------ ---------- ------- ----------- ---- --------
                // cbPerObject                       cbuffer      NA          NA    0        1
                //
                //
                //
                // Input signature:
                //
                // Name                 Index   Mask Register SysValue Format   Used
                // -------------------- ----- ------ -------- -------- ------ ------
                // POSTION                  0   xyz         0     NONE  float   xyz 
                // TEXCOORD                 0   xy          1     NONE  float   xy  
                //
                //
                // Output signature:
                //
                // Name                 Index   Mask Register SysValue Format   Used
                // -------------------- ----- ------ -------- -------- ------ ------
                // m0:SV_POSITION           0   xyzw        0      POS  float   xyzw
                // m0:TEXCOORD              0   xy          1     NONE  float   xy  
                //
                gs_5_0
                dcl_globalFlags refactoringAllowed
                dcl_constantbuffer cb0[4], immediateIndexed
                dcl_input v[3][0].xyz
                dcl_input v[3][1].xy
                dcl_temps 4
                dcl_inputprimitive triangle 
                dcl_stream m0
                dcl_outputtopology trianglestrip 
                dcl_output_siv o0.xyzw, position
                dcl_output o1.xy
                dcl_maxout 6
                
                #line 67 "CPSurfaces-NormalDepthTech.fx"
                mov r0.xyz, v[0][0].xyzx
                mov r0.w, l(1.000000)
                dp4 r1.x, r0.xyzw, cb0[0].xyzw
                dp4 r1.y, r0.xyzw, cb0[1].xyzw
                dp4 r1.z, r0.xyzw, cb0[2].xyzw
                dp4 r0.x, r0.xyzw, cb0[3].xyzw
                mov r2.xyz, v[1][0].xyzx
                mov r2.w, l(1.000000)
                dp4 r0.y, r2.xyzw, cb0[0].xyzw
                dp4 r0.z, r2.xyzw, cb0[1].xyzw
                dp4 r0.w, r2.xyzw, cb0[2].xyzw
                dp4 r1.w, r2.xyzw, cb0[3].xyzw
                mov r2.xyz, v[2][0].xyzx
                mov r2.w, l(1.000000)
                dp4 r3.x, r2.xyzw, cb0[0].xyzw
                dp4 r3.y, r2.xyzw, cb0[1].xyzw
                dp4 r3.z, r2.xyzw, cb0[2].xyzw
                dp4 r2.x, r2.xyzw, cb0[3].xyzw
                
                #line 71
                mov o0.x, r1.x  // triStream<0>
                mov o0.y, r1.y  // triStream<0>
                mov o0.z, r1.z  // triStream<0>
                mov o0.w, r0.x  // triStream<0>
                mov o1.xy, v[0][1].xyxx  // triStream<0,0>
                emit_stream m0
                mov o0.x, r0.y  // triStream<0>
                mov o0.y, r0.z  // triStream<0>
                mov o0.z, r0.w  // triStream<0>
                mov o0.w, r1.w  // triStream<0>
                mov o1.xy, v[1][1].xyxx  // triStream<0,0>
                emit_stream m0
                mov o0.x, r3.x  // triStream<0>
                mov o0.y, r3.y  // triStream<0>
                mov o0.z, r3.z  // triStream<0>
                mov o0.w, r2.x  // triStream<0>
                mov o1.xy, v[2][1].xyxx  // triStream<0,0>
                emit_stream m0
                
                #line 60
                ret 
                // Approximately 37 instruction slots used
                            
            };
            PixelShader = asm {
                //
                // Generated by Microsoft (R) HLSL Shader Compiler 9.29.952.3111
                //
                //
                // Resource Bindings:
                //
                // Name                                 Type  Format         Dim Slot Elements
                // ------------------------------ ---------- ------- ----------- ---- --------
                // linearSampler                     sampler      NA          NA    0        1
                // gDiffuseMap                       texture  float4          2d    0        1
                //
                //
                //
                // Input signature:
                //
                // Name                 Index   Mask Register SysValue Format   Used
                // -------------------- ----- ------ -------- -------- ------ ------
                // SV_POSITION              0   xyzw        0      POS  float       
                // TEXCOORD                 0   xy          1     NONE  float   xy  
                //
                //
                // Output signature:
                //
                // Name                 Index   Mask Register SysValue Format   Used
                // -------------------- ----- ------ -------- -------- ------ ------
                // no Output
                ps_5_0
                dcl_globalFlags refactoringAllowed
                dcl_sampler s0, mode_default
                dcl_resource_texture2d (float,float,float,float) t0
                dcl_input_ps linear v1.xy
                dcl_temps 1
                
                #line 78 "CPSurfaces-NormalDepthTech.fx"
                sample_indexable(texture2d)(float,float,float,float) r0.x, v1.xyxx, t0.wxyz, s0
                mov r0.x, r0.x  // diffuse<0:Inf>
                add r0.x, r0.x, l(-0.150000)
                lt r0.x, r0.x, l(0.000000)
                and r0.x, r0.x, l(-1)
                discard r0.x
                
                #line 76
                ret 
                // Approximately 7 instruction slots used
                            
            };
            RasterizerState = Depth;
        }

    }

}

